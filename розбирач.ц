взяти визначення ./розбирач;

зовнішня дія read_file(path: памʼять<char>, path_size: size_t, out: адреса<памʼять<char>>): size_t;
зовнішня дія malloc(size: size_t): невідома_адреса;
зовнішня дія realloc(value: невідома_адреса, size: size_t): невідома_адреса;
зовнішня дія free(value: невідома_адреса);
зовнішня дія putchar(value: char): int;
зовнішня дія print_long(value: long);
зовнішня дія println_long(value: long);

дія виділити<Т>(): адреса<Т>;
дія перевиділити<Т>(значення: адреса<Т>, кількість: позитивне): памʼять<Т>;
дія звільнити(значення: невідома_адреса);
дія виділити_памʼять<Т>(кількість: позитивне): памʼять<Т>;
дія перевиділити_памʼять<Т>(значення: памʼять<Т>, кількість: позитивне): памʼять<Т>;
дія звільнити_памʼять(значення: невідома_памʼять);

дія виділити<Т>(): адреса<Т> {
  вернути malloc(size_t(Т.розмір)) як адреса<Т>;
}

дія перевиділити<Т>(значення: адреса<Т>, кількість: позитивне): памʼять<Т> {
  вернути realloc(значення як невідома_адреса, size_t(кількість * Т.розмір)) як памʼять<Т>;
}

дія звільнити(значення: невідома_адреса) {
  free(значення як невідома_адреса);
}

дія виділити_памʼять<Т>(кількість: позитивне): памʼять<Т> {
  вернути malloc(size_t(кількість * Т.розмір)) як памʼять<Т>;
}

дія перевиділити_памʼять<Т>(значення: памʼять<Т>, кількість: позитивне): памʼять<Т> {
  вернути realloc(значення як невідома_адреса, size_t(кількість * Т.розмір)) як памʼять<Т>;
}

дія звільнити_памʼять(значення: невідома_памʼять) {
  free(значення як невідома_адреса);
}

дія вивести_ю8(значення: ю8) {
  змінна ціль п: позитивне = 0;
  поки п < значення.розмір {
    putchar(char(значення.дані[п]));
    п += 1;
  }
}

дія надрукувати_ю8(значення: ю8) {
  змінна ціль п: позитивне = 0;
  поки п < значення.розмір {
    putchar(char(значення.дані[п]));
    п += 1;
  }
  putchar(10);
}

дія вивести_п64(значення: п64) {
  print_long(long(значення));
}

дія надрукувати_п64(значення: п64) {
  println_long(long(значення));
}

дія ЯТУТ() {
  надрукувати_ю8(ю8"ЯТУТ");
}

структура ю32 {
  дані: памʼять<п32>;
  розмір: позитивне;
}

структура Накопичувач<Т> {
  розмір: позитивне;
  вмісткість: позитивне;
  дані: памʼять<Т>;
}

дія зробити_накопичувач<Т>(): Накопичувач<Т> {
  вернути Накопичувач<Т> {
    розмір = 0,
    вмісткість = 0,
    дані = пусто
  };
}

дія покласти_в_накопичувач<Т>(накопичувач: адреса<Накопичувач<Т>>, дані: Т) {
  якщо накопичувач.розмір == накопичувач.вмісткість {
    накопичувач.вмісткість += 1;
    накопичувач.дані = перевиділити_памʼять<Т>(накопичувач.дані, накопичувач.вмісткість);
  }
  накопичувач.дані[накопичувач.розмір] = дані;
  накопичувач.розмір += 1;
}

дія звільнити_дані_накопичувача<Т>(накопичувач: Накопичувач<Т>) {
  звільнити_памʼять(накопичувач.дані);
}

дія звільнити_накопичувач<Т>(накопичувач: адреса<Накопичувач<Т>>) {
  звільнити_памʼять(накопичувач.дані);
  звільнити(накопичувач);
}

дія порахувати_розмір_ю8сі(значення: памʼять<п8>): позитивне {
  змінна ціль п: позитивне = 0;
  поки значення[п] != 0 {
    п += 1;
  }
  вернути п;
}

дія дізнатись_розмір_символа_юнікоду(перший_байт: п8): п8 {
  якщо (перший_байт & 128) == 0 {
    вернути 1;
  }
  якщо (перший_байт & 224) == 192 {
    вернути 2;
  }
  якщо (перший_байт & 240) == 224 {
    вернути 3;
  }
  якщо (перший_байт & 248) == 240 {
    вернути 4;
  }
  вернути 0;
}

дія перекодувати_ю8_в_ю32(вхід: ю8, вихід: адреса<ю32>): логічне {
  змінна ціль дані_виходу = виділити_памʼять<п32>(вхід.розмір);
  змінна ціль розмір_виходу: позитивне = 0;
  змінна ціль п: позитивне = 0;
  поки п < вхід.розмір {
    ціль перший_байт = вхід.дані[п];
    ціль розмір_символа = дізнатись_розмір_символа_юнікоду(перший_байт);
    якщо розмір_символа == 1 {
      дані_виходу[розмір_виходу] = п32(перший_байт & 127);
      розмір_виходу += 1;
    }
    якщо розмір_символа == 2 {
      ціль другий_байт = вхід.дані[п + 1];
      дані_виходу[розмір_виходу] = (п32(перший_байт & 31) << 6) | п32(другий_байт & 63);
      розмір_виходу += 1;
      п += 1;
    }
    якщо розмір_символа == 3 {
      ціль другий_байт = вхід.дані[п + 1];
      ціль третій_байт = вхід.дані[п + 2];
      дані_виходу[розмір_виходу] = (п32(перший_байт & 15) << 12) | (п32(другий_байт & 63) << 6) | п32(третій_байт & 63);
      розмір_виходу += 1;
      п += 2;
    }
    якщо розмір_символа == 4 {
      ціль другий_байт = вхід.дані[п + 1];
      ціль третій_байт = вхід.дані[п + 2];
      ціль четвертий_байт = вхід.дані[п + 3];
      дані_виходу[розмір_виходу] = (п32(перший_байт & 15) << 18) | (п32(другий_байт & 63) << 12) | (п32(третій_байт & 63) << 6) | п32(четвертий_байт & 63);
      розмір_виходу += 1;
      п += 3;
    }
    п += 1;
  }
  дані_виходу[розмір_виходу] = 0;
  дані_виходу = перевиділити_памʼять<п32>(дані_виходу, розмір_виходу);
  вихід::вміст = ю32 {
    дані_виходу,
    розмір_виходу
  };
  вернути так;
}

секція мавка {
  дія звільнити_гілку(гілка: адреса<Гілка>);
  дія звільнити_тіло(тіло: СписокГілок);
  дія звільнити_тип(тип: Тип);
  дія звільнити_параметри(кількість_параметрів: позитивне, параметри: памʼять<Параметр>);

  дія звільнити_гілку(гілка: адреса<Гілка>) {
    якщо гілка != пусто {
      звільнити(гілка);
    }
  }

  дія звільнити_тіло(тіло: СписокГілок) {
    змінна ціль п: позитивне = 0;
    поки п < тіло.довжина {
      звільнити_гілку(тіло.елементи[п]);
      п += 1;
    }
    звільнити_памʼять(тіло.елементи);
  }

  дія звільнити_тип(тип: Тип) {
    змінна ціль п: позитивне = 0;
    поки п < тип.кількість_гілок {
      звільнити_гілку(тип.гілки[п]);
      п += 1;
    }
    звільнити_памʼять(тип.гілки);
  }

  дія звільнити_параметри(кількість_параметрів: позитивне, параметри: памʼять<Параметр>) {
    змінна ціль п: позитивне = 0;
    поки п < кількість_параметрів {
      якщо параметри[п].тип.заповнено == позитивне(так) {
        звільнити_тип(параметри[п].тип.значення);
      }
      звільнити_гілку(параметри[п].значення);
      п += 1;
    }
    звільнити_памʼять(параметри);
  }

  дія вивести_гілку(гілка: адреса<Гілка>) {
    якщо гілка == пусто {
      вивести_ю8(ю8"ПУСТО");
    } інакше якщо гілка.вид == ВидГілкиНіщо {
      вивести_ю8(ю8"НІЩО");
    } інакше якщо гілка.вид == ВидГілкиВизначити {
      ціль дані = гілка.дані як ДаніГілкиВизначити;
      вивести_ю8(ю8"Визначити(Ідентифікатор, ");
      вивести_гілку(дані.значення);
      вивести_ю8(ю8")");
    } інакше якщо гілка.вид == ВидГілкиЗвернутись {
      вивести_ю8(ю8"Звернутись(Ідентифікатор)");
    } інакше якщо гілка.вид == ВидГілкиОтримати {
      ціль дані = гілка.дані як ДаніГілкиОтримати;
      вивести_ю8(ю8"Отримати(");
      вивести_гілку(дані.предмет);
      вивести_ю8(ю8", Ідентифікатор)");
    } інакше якщо гілка.вид == ВидГілкиОтриматиЕлемент {
      ціль дані = гілка.дані як ДаніГілкиОтриматиЕлемент;
      вивести_ю8(ю8"ОтриматиЕлемент(");
      вивести_гілку(дані.предмет);
      вивести_ю8(ю8", ");
      вивести_гілку(дані.ключ);
      вивести_ю8(ю8")");
    } інакше якщо гілка.вид == ВидГілкиЗмінити {
      ціль дані = гілка.дані як ДаніГілкиЗмінити;
      вивести_ю8(ю8"Змінити(");
      вивести_гілку(дані.предмет);
      вивести_ю8(ю8", Ідентифікатор, ");
      вивести_гілку(дані.значення);
      вивести_ю8(ю8")");
    } інакше якщо гілка.вид == ВидГілкиЗмінитиЕлемент {
      ціль дані = гілка.дані як ДаніГілкиЗмінитиЕлемент;
      вивести_ю8(ю8"ЗмінитиЕлемент(");
      вивести_гілку(дані.предмет);
      вивести_ю8(ю8", ");
      вивести_гілку(дані.ключ);
      вивести_ю8(ю8", ");
      вивести_гілку(дані.значення);
      вивести_ю8(ю8")");
    } інакше якщо гілка.вид == ВидГілкиВиконати {
      ціль дані = гілка.дані як ДаніГілкиВиконати;
      вивести_ю8(ю8"Виконати");
      вивести_ю8(ю8"(");
      вивести_гілку(дані.предмет);
      вивести_ю8(ю8", [");
      змінна ціль п: позитивне = 0;
      поки п < дані.кількість_аргументів {
        якщо дані.аргументи[п].ідентифікатор.заповнено == позитивне(так) {
          вивести_ю8(ю8"Ідентифікатор=");
        }
        вивести_гілку(дані.аргументи[п].значення);
        якщо п != дані.кількість_аргументів - 1 {
          вивести_ю8(ю8", ");
        }
        п += 1;
      }
      вивести_ю8(ю8"]");
      вивести_ю8(ю8")");
    } інакше якщо гілка.вид == ВидГілкиДія {
      вивести_ю8(ю8"Дія");
    } інакше якщо гілка.вид == ВидГілкиСтруктура {
      вивести_ю8(ю8"Структура");
    } інакше якщо гілка.вид == ВидГілкиЧисло {
      вивести_ю8(ю8"Число");
    } інакше якщо гілка.вид == ВидГілкиТекст {
      вивести_ю8(ю8"Текст");
    } інакше якщо гілка.вид == ВидГілкиОперація {
      вивести_ю8(ю8"Операція");
    } інакше якщо гілка.вид == ВидГілкиЯкщо {
      вивести_ю8(ю8"Якщо");
    } інакше якщо гілка.вид == ВидГілкиПоки {
      вивести_ю8(ю8"Поки");
    } інакше якщо гілка.вид == ВидГілкиВернути {
      ціль дані = гілка.дані як ДаніГілкиВернути;
      вивести_ю8(ю8"Вернути(");
      якщо дані.значення != пусто {
        вивести_гілку(дані.значення);
      }
      вивести_ю8(ю8")");
    } інакше якщо гілка.вид == ВидГілкиЗначенняЯкщо {
      вивести_ю8(ю8"ЗначенняЯкщо");
    } інакше якщо гілка.вид == ВидГілкиСамоОперація {
      вивести_ю8(ю8"СамоОперація");
    } інакше якщо гілка.вид == ВидГілкиВзяти {
      ціль дані = гілка.дані як ДаніГілкиВзяти;
      вивести_ю8(ю8"Взяти(Ідентифікатор, [");
      змінна ціль п: позитивне = 0;
      поки п < дані.довжина_шляху {
        ціль елемент_шляху = дані.шлях[п];
        вивести_ю8(ю8"Ідентифікатор");
        якщо п != дані.довжина_шляху - 1 {
          вивести_ю8(ю8", ");
        }
        п += 1;
      }
      вивести_ю8(ю8"]");
      п = 0;
      якщо дані.ідентифікатор_як.заповнено == позитивне(так) {
        вивести_ю8(ю8", Ідентифікатор");
      } інакше якщо дані.кількість_елементів > 0 {
        вивести_ю8(ю8", [");
        поки п < дані.кількість_елементів {
          ціль елемент = дані.елементи[п];
          вивести_ю8(ю8"ЕлементВзяти(Ідентифікатор");
          якщо елемент.ідентифікатор_як.заповнено == позитивне(так) {
            вивести_ю8(ю8" як Ідентифікатор");
          }
          вивести_ю8(ю8")");
          якщо п != дані.кількість_елементів - 1 {
            вивести_ю8(ю8", ");
          }
          п += 1;
        }
        вивести_ю8(ю8"]");

      }
      вивести_ю8(ю8")");
    } інакше якщо гілка.вид == ВидГілкиСпробувати {
      вивести_ю8(ю8"Спробувати");
    } інакше якщо гілка.вид == ВидГілкиВпасти {
      ціль дані = гілка.дані як ДаніГілкиВпасти;
      вивести_ю8(ю8"Впасти(");
      якщо дані.значення != пусто {
        вивести_гілку(дані.значення);
      }
      вивести_ю8(ю8")");
    } інакше якщо гілка.вид == ВидГілкиДати {
      ціль дані = гілка.дані як ДаніГілкиДати;
      вивести_ю8(ю8"Дати([");
      змінна ціль п: позитивне = 0;
      поки п < дані.кількість_елементів {
        ціль елемент = дані.елементи[п];
        вивести_ю8(ю8"ЕлементДати(Ідентифікатор");
        якщо елемент.ідентифікатор_як.заповнено == позитивне(так) {
          вивести_ю8(ю8" як Ідентифікатор");
        }
        вивести_ю8(ю8")");
        якщо п != дані.кількість_елементів - 1 {
          вивести_ю8(ю8", ");
        }
        п += 1;
      }
      вивести_ю8(ю8"])");
    } інакше якщо гілка.вид == ВидГілкиМодуль {
      вивести_ю8(ю8"Модуль");
    } інакше якщо гілка.вид == ВидГілкиСписок {
      вивести_ю8(ю8"Список");
    } інакше якщо гілка.вид == ВидГілкиСловник {
      вивести_ю8(ю8"Словник");
    } інакше якщо гілка.вид == ВидГілкиСимвол {
      вивести_ю8(ю8"Символ");
    } інакше якщо гілка.вид == ВидГілкиПеребрати {
      вивести_ю8(ю8"Перебрати");
    } інакше якщо гілка.вид == ВидГілкиЦикл {
      вивести_ю8(ю8"Цикл");
    } інакше якщо гілка.вид == ВидГілкиВизначитиЗзовні {
      вивести_ю8(ю8"ВизначитиЗзовні");
    } інакше якщо гілка.вид == ВидГілкиПеребратиДіапазон {
      вивести_ю8(ю8"ПеребратиДіапазон");
    } інакше якщо гілка.вид == ВидГілкиВічнийЦикл {
      вивести_ю8(ю8"ВічнийЦикл");
    } інакше якщо гілка.вид == ВидГілкиВидалити {
      вивести_ю8(ю8"Видалити");
    } інакше якщо гілка.вид == ВидГілкиВидалитиВластивість {
      вивести_ю8(ю8"ВидалитиВластивість");
    } інакше якщо гілка.вид == ВидГілкиВидалитиЕлемент {
      вивести_ю8(ю8"ВидалитиЕлемент");
    } інакше якщо гілка.вид == ВидГілкиЧекати {
      вивести_ю8(ю8"Чекати");
    } інакше {
      вивести_ю8(ю8"НЕВІДОМА ГІЛКА");
    }
  }
}

секція мавка {
  синонім ВидСловаАбо = 0;
  синонім ВидСловаБільше = 1;
  синонім ВидСловаВзяти = 2;
  синонім ВидСловаВласна = 3;
  синонім ВидСловаВпасти = 4;
  синонім ВидСловаВидалити = 5;
  синонім ВидСловаВнутрішня = 6;
  синонім ВидСловаВластивість = 7;
  синонім ВидСловаВернути = 8;
  синонім ВидСловаДія = 9;
  синонім ВидСловаДати = 10;
  синонім ВидСловаЄ = 11;
  синонім ВидСловаЗовнішня = 12;
  синонім ВидСловаЗловити = 13;
  синонім ВидСловаІ = 14;
  синонім ВидСловаІнакше = 15;
  синонім ВидСловаКомпозиція = 16;
  синонім ВидСловаКінець = 17;
  синонім ВидСловаМодуль = 18;
  синонім ВидСловаМенше = 19;
  синонім ВидСловаМістить = 20;
  синонім ВидСловаМісцева = 21;
  синонім ВидСловаНе = 22;
  синонім ВидСловаПоки = 23;
  синонім ВидСловаПерелік = 24;
  синонім ВидСловаПредок = 25;
  синонім ВидСловаПеребрати = 26;
  синонім ВидСловаРівно = 27;
  синонім ВидСловаСтруктура = 28;
  синонім ВидСловаСпробувати = 29;
  синонім ВидСловаСпец = 30;
  синонім ВидСловаТривала = 31;
  синонім ВидСловаЦикл = 32;
  синонім ВидСловаЦе = 33;
  синонім ВидСловаЧекати = 34;
  синонім ВидСловаЯк = 35;
  синонім ВидСловаЯкщо = 36;

  синонім ВидСловаСимволРівно = 37;
  синонім ВидСловаСимволБільше = 38;
  синонім ВидСловаСимволМенше = 39;
  синонім ВидСловаСимволКрапка = 40;
  синонім ВидСловаСимволПлюс = 41;
  синонім ВидСловаСимволМінус = 42;
  синонім ВидСловаСимволПомножити = 43;
  синонім ВидСловаСимволПоділити = 44;
  синонім ВидСловаСимволЗалишку = 45;
  синонім ВидСловаСимволПірамідка = 46;
  синонім ВидСловаСимволІ = 47;
  синонім ВидСловаСимволАбо = 48;
  синонім ВидСловаСимволВідкритаДужка = 49;
  синонім ВидСловаСимволЗакритаДужка = 50;
  синонім ВидСловаСимволКвадратнаВідкритаДужка = 51;
  синонім ВидСловаСимволКвадратнаЗакритаДужка = 52;
  синонім ВидСловаСимволЗнакПитання = 53;
  синонім ВидСловаСимволДвокрапка = 54;
  синонім ВидСловаСимволТильда = 55;
  синонім ВидСловаСимволОднолапка = 56;
  синонім ВидСловаСимволДволапка = 57;
  синонім ВидСловаСимволЗнакОклику = 58;
  синонім ВидСловаСимволКома = 59;
  синонім ВидСловаСимволМіжряд = 60;

  синонім ВидСловаЧисло = 61;
  синонім ВидСловаДесятковеЧисло = 62;
  синонім ВидСловаСимвол = 63;
  синонім ВидСловаТекст = 64;
  синонім ВидСловаБагаторядковийТекст = 65;
  синонім ВидСловаКоментар = 66;
  синонім ВидСловаБагаторядковийКоментар = 67;
  синонім ВидСловаІдентифікатор = 68;

  синонім ВидСловаКІНЕЦЬСЛІВ = 100;

  синонім UNICODE_SPACE = 32;
  синонім UNICODE_DOT = 46;
  синонім UNICODE_0 = 48;
  синонім UNICODE_1 = 49;
  синонім UNICODE_2 = 50;
  синонім UNICODE_3 = 51;
  синонім UNICODE_4 = 52;
  синонім UNICODE_5 = 53;
  синонім UNICODE_6 = 54;
  синонім UNICODE_7 = 55;
  синонім UNICODE_8 = 56;
  синонім UNICODE_9 = 57;

  структура Слово {
    вид: позитивне;
    позиція_початку: позитивне;
    позиція_кінця: позитивне;
  }

  дія надрукувати_слова(слова: Накопичувач<Слово>) {
    змінна ціль п: позитивне = 0;
    поки п < слова.розмір {
      ціль слово = слова.дані[п];
      якщо слово.вид == ВидСловаКінець {
        вивести_ю8(ю8"Кінець");
        вивести_ю8(ю8" ");
        вивести_п64(слово.позиція_початку);
        вивести_ю8(ю8" ");
        надрукувати_п64(слово.позиція_кінця);
      } інакше якщо слово.вид == ВидСловаДія {
        вивести_ю8(ю8"Дія");
        вивести_ю8(ю8" ");
        вивести_п64(слово.позиція_початку);
        вивести_ю8(ю8" ");
        надрукувати_п64(слово.позиція_кінця);
      } інакше якщо слово.вид == ВидСловаСтруктура {
        вивести_ю8(ю8"Структура");
        вивести_ю8(ю8" ");
        вивести_п64(слово.позиція_початку);
        вивести_ю8(ю8" ");
        надрукувати_п64(слово.позиція_кінця);
      } інакше якщо слово.вид == ВидСловаПеребрати {
        вивести_ю8(ю8"Перебрати");
        вивести_ю8(ю8" ");
        вивести_п64(слово.позиція_початку);
        вивести_ю8(ю8" ");
        надрукувати_п64(слово.позиція_кінця);
      } інакше якщо слово.вид == ВидСловаЦикл {
        вивести_ю8(ю8"Цикл");
        вивести_ю8(ю8" ");
        вивести_п64(слово.позиція_початку);
        вивести_ю8(ю8" ");
        надрукувати_п64(слово.позиція_кінця);
      } інакше якщо слово.вид == ВидСловаЯкщо {
        вивести_ю8(ю8"Якщо");
        вивести_ю8(ю8" ");
        вивести_п64(слово.позиція_початку);
        вивести_ю8(ю8" ");
        надрукувати_п64(слово.позиція_кінця);
      } інакше якщо слово.вид == ВидСловаЧекати {
        вивести_ю8(ю8"Чекати");
        вивести_ю8(ю8" ");
        вивести_п64(слово.позиція_початку);
        вивести_ю8(ю8" ");
        надрукувати_п64(слово.позиція_кінця);
      } інакше якщо слово.вид == ВидСловаВзяти {
        вивести_ю8(ю8"Взяти");
        вивести_ю8(ю8" ");
        вивести_п64(слово.позиція_початку);
        вивести_ю8(ю8" ");
        надрукувати_п64(слово.позиція_кінця);
      } інакше якщо слово.вид == ВидСловаДати {
        вивести_ю8(ю8"Дати");
        вивести_ю8(ю8" ");
        вивести_п64(слово.позиція_початку);
        вивести_ю8(ю8" ");
        надрукувати_п64(слово.позиція_кінця);
      } інакше якщо слово.вид == ВидСловаЯк {
        вивести_ю8(ю8"Як");
        вивести_ю8(ю8" ");
        вивести_п64(слово.позиція_початку);
        вивести_ю8(ю8" ");
        надрукувати_п64(слово.позиція_кінця);
      } інакше якщо слово.вид == ВидСловаЄ {
        вивести_ю8(ю8"Є");
        вивести_ю8(ю8" ");
        вивести_п64(слово.позиція_початку);
        вивести_ю8(ю8" ");
        надрукувати_п64(слово.позиція_кінця);
      } інакше якщо слово.вид == ВидСловаСпец {
        вивести_ю8(ю8"Спец");
        вивести_ю8(ю8" ");
        вивести_п64(слово.позиція_початку);
        вивести_ю8(ю8" ");
        надрукувати_п64(слово.позиція_кінця);
      } інакше якщо слово.вид == ВидСловаВернути {
        вивести_ю8(ю8"Вернути");
        вивести_ю8(ю8" ");
        вивести_п64(слово.позиція_початку);
        вивести_ю8(ю8" ");
        надрукувати_п64(слово.позиція_кінця);
      } інакше якщо слово.вид == ВидСловаТривала {
        вивести_ю8(ю8"Тривала");
        вивести_ю8(ю8" ");
        вивести_п64(слово.позиція_початку);
        вивести_ю8(ю8" ");
        надрукувати_п64(слово.позиція_кінця);
      } інакше якщо слово.вид == ВидСловаВласна {
        вивести_ю8(ю8"Власна");
        вивести_ю8(ю8" ");
        вивести_п64(слово.позиція_початку);
        вивести_ю8(ю8" ");
        надрукувати_п64(слово.позиція_кінця);
      } інакше якщо слово.вид == ВидСловаІ {
        вивести_ю8(ю8"І");
        вивести_ю8(ю8" ");
        вивести_п64(слово.позиція_початку);
        вивести_ю8(ю8" ");
        надрукувати_п64(слово.позиція_кінця);
      } інакше якщо слово.вид == ВидСловаАбо {
        вивести_ю8(ю8"Або");
        вивести_ю8(ю8" ");
        вивести_п64(слово.позиція_початку);
        вивести_ю8(ю8" ");
        надрукувати_п64(слово.позиція_кінця);
      } інакше якщо слово.вид == ВидСловаСпробувати {
        вивести_ю8(ю8"Спробувати");
        вивести_ю8(ю8" ");
        вивести_п64(слово.позиція_початку);
        вивести_ю8(ю8" ");
        надрукувати_п64(слово.позиція_кінця);
      } інакше якщо слово.вид == ВидСловаЗловити {
        вивести_ю8(ю8"Зловити");
        вивести_ю8(ю8" ");
        вивести_п64(слово.позиція_початку);
        вивести_ю8(ю8" ");
        надрукувати_п64(слово.позиція_кінця);
      } інакше якщо слово.вид == ВидСловаІнакше {
        вивести_ю8(ю8"Інакше");
        вивести_ю8(ю8" ");
        вивести_п64(слово.позиція_початку);
        вивести_ю8(ю8" ");
        надрукувати_п64(слово.позиція_кінця);
      } інакше якщо слово.вид == ВидСловаВпасти {
        вивести_ю8(ю8"Впасти");
        вивести_ю8(ю8" ");
        вивести_п64(слово.позиція_початку);
        вивести_ю8(ю8" ");
        надрукувати_п64(слово.позиція_кінця);
      } інакше якщо слово.вид == ВидСловаПоки {
        вивести_ю8(ю8"Поки");
        вивести_ю8(ю8" ");
        вивести_п64(слово.позиція_початку);
        вивести_ю8(ю8" ");
        надрукувати_п64(слово.позиція_кінця);
      } інакше якщо слово.вид == ВидСловаМодуль {
        вивести_ю8(ю8"Модуль");
        вивести_ю8(ю8" ");
        вивести_п64(слово.позиція_початку);
        вивести_ю8(ю8" ");
        надрукувати_п64(слово.позиція_кінця);
      } інакше якщо слово.вид == ВидСловаРівно {
        вивести_ю8(ю8"Рівно");
        вивести_ю8(ю8" ");
        вивести_п64(слово.позиція_початку);
        вивести_ю8(ю8" ");
        надрукувати_п64(слово.позиція_кінця);
      } інакше якщо слово.вид == ВидСловаБільше {
        вивести_ю8(ю8"Більше");
        вивести_ю8(ю8" ");
        вивести_п64(слово.позиція_початку);
        вивести_ю8(ю8" ");
        надрукувати_п64(слово.позиція_кінця);
      } інакше якщо слово.вид == ВидСловаМенше {
        вивести_ю8(ю8"Менше");
        вивести_ю8(ю8" ");
        вивести_п64(слово.позиція_початку);
        вивести_ю8(ю8" ");
        надрукувати_п64(слово.позиція_кінця);
      } інакше якщо слово.вид == ВидСловаМістить {
        вивести_ю8(ю8"Містить");
        вивести_ю8(ю8" ");
        вивести_п64(слово.позиція_початку);
        вивести_ю8(ю8" ");
        надрукувати_п64(слово.позиція_кінця);
      } інакше якщо слово.вид == ВидСловаНе {
        вивести_ю8(ю8"Не");
        вивести_ю8(ю8" ");
        вивести_п64(слово.позиція_початку);
        вивести_ю8(ю8" ");
        надрукувати_п64(слово.позиція_кінця);
      } інакше якщо слово.вид == ВидСловаПредок {
        вивести_ю8(ю8"Предок");
        вивести_ю8(ю8" ");
        вивести_п64(слово.позиція_початку);
        вивести_ю8(ю8" ");
        надрукувати_п64(слово.позиція_кінця);
      } інакше якщо слово.вид == ВидСловаЦе {
        вивести_ю8(ю8"Це");
        вивести_ю8(ю8" ");
        вивести_п64(слово.позиція_початку);
        вивести_ю8(ю8" ");
        надрукувати_п64(слово.позиція_кінця);
      } інакше якщо слово.вид == ВидСловаПерелік {
        вивести_ю8(ю8"Перелік");
        вивести_ю8(ю8" ");
        вивести_п64(слово.позиція_початку);
        вивести_ю8(ю8" ");
        надрукувати_п64(слово.позиція_кінця);
      } інакше якщо слово.вид == ВидСловаКомпозиція {
        вивести_ю8(ю8"Композиція");
        вивести_ю8(ю8" ");
        вивести_п64(слово.позиція_початку);
        вивести_ю8(ю8" ");
        надрукувати_п64(слово.позиція_кінця);
      } інакше якщо слово.вид == ВидСловаЗовнішня {
        вивести_ю8(ю8"Зовнішня");
        вивести_ю8(ю8" ");
        вивести_п64(слово.позиція_початку);
        вивести_ю8(ю8" ");
        надрукувати_п64(слово.позиція_кінця);
      } інакше якщо слово.вид == ВидСловаВнутрішня {
        вивести_ю8(ю8"Внутрішня");
        вивести_ю8(ю8" ");
        вивести_п64(слово.позиція_початку);
        вивести_ю8(ю8" ");
        надрукувати_п64(слово.позиція_кінця);
      } інакше якщо слово.вид == ВидСловаМісцева {
        вивести_ю8(ю8"Місцева");
        вивести_ю8(ю8" ");
        вивести_п64(слово.позиція_початку);
        вивести_ю8(ю8" ");
        надрукувати_п64(слово.позиція_кінця);
      } інакше якщо слово.вид == ВидСловаВластивість {
        вивести_ю8(ю8"Властивість");
        вивести_ю8(ю8" ");
        вивести_п64(слово.позиція_початку);
        вивести_ю8(ю8" ");
        надрукувати_п64(слово.позиція_кінця);
      } інакше якщо слово.вид == ВидСловаВидалити {
        вивести_ю8(ю8"Видалити");
        вивести_ю8(ю8" ");
        вивести_п64(слово.позиція_початку);
        вивести_ю8(ю8" ");
        надрукувати_п64(слово.позиція_кінця);
      } інакше якщо слово.вид == ВидСловаСимволРівно {
        вивести_ю8(ю8"СимволРівно");
        вивести_ю8(ю8" ");
        вивести_п64(слово.позиція_початку);
        вивести_ю8(ю8" ");
        надрукувати_п64(слово.позиція_кінця);
      } інакше якщо слово.вид == ВидСловаСимволБільше {
        вивести_ю8(ю8"СимволБільше");
        вивести_ю8(ю8" ");
        вивести_п64(слово.позиція_початку);
        вивести_ю8(ю8" ");
        надрукувати_п64(слово.позиція_кінця);
      } інакше якщо слово.вид == ВидСловаСимволМенше {
        вивести_ю8(ю8"СимволМенше");
        вивести_ю8(ю8" ");
        вивести_п64(слово.позиція_початку);
        вивести_ю8(ю8" ");
        надрукувати_п64(слово.позиція_кінця);
      } інакше якщо слово.вид == ВидСловаСимволКрапка {
        вивести_ю8(ю8"СимволКрапка");
        вивести_ю8(ю8" ");
        вивести_п64(слово.позиція_початку);
        вивести_ю8(ю8" ");
        надрукувати_п64(слово.позиція_кінця);
      } інакше якщо слово.вид == ВидСловаСимволПлюс {
        вивести_ю8(ю8"СимволПлюс");
        вивести_ю8(ю8" ");
        вивести_п64(слово.позиція_початку);
        вивести_ю8(ю8" ");
        надрукувати_п64(слово.позиція_кінця);
      } інакше якщо слово.вид == ВидСловаСимволМінус {
        вивести_ю8(ю8"СимволМінус");
        вивести_ю8(ю8" ");
        вивести_п64(слово.позиція_початку);
        вивести_ю8(ю8" ");
        надрукувати_п64(слово.позиція_кінця);
      } інакше якщо слово.вид == ВидСловаСимволПомножити {
        вивести_ю8(ю8"СимволПомножити");
        вивести_ю8(ю8" ");
        вивести_п64(слово.позиція_початку);
        вивести_ю8(ю8" ");
        надрукувати_п64(слово.позиція_кінця);
      } інакше якщо слово.вид == ВидСловаСимволПоділити {
        вивести_ю8(ю8"СимволПоділити");
        вивести_ю8(ю8" ");
        вивести_п64(слово.позиція_початку);
        вивести_ю8(ю8" ");
        надрукувати_п64(слово.позиція_кінця);
      } інакше якщо слово.вид == ВидСловаСимволЗалишку {
        вивести_ю8(ю8"СимволЗалишку");
        вивести_ю8(ю8" ");
        вивести_п64(слово.позиція_початку);
        вивести_ю8(ю8" ");
        надрукувати_п64(слово.позиція_кінця);
      } інакше якщо слово.вид == ВидСловаСимволПірамідка {
        вивести_ю8(ю8"СимволПідамідка");
        вивести_ю8(ю8" ");
        вивести_п64(слово.позиція_початку);
        вивести_ю8(ю8" ");
        надрукувати_п64(слово.позиція_кінця);
      } інакше якщо слово.вид == ВидСловаСимволІ {
        вивести_ю8(ю8"СимволІ");
        вивести_ю8(ю8" ");
        вивести_п64(слово.позиція_початку);
        вивести_ю8(ю8" ");
        надрукувати_п64(слово.позиція_кінця);
      } інакше якщо слово.вид == ВидСловаСимволАбо {
        вивести_ю8(ю8"СимволАбо");
        вивести_ю8(ю8" ");
        вивести_п64(слово.позиція_початку);
        вивести_ю8(ю8" ");
        надрукувати_п64(слово.позиція_кінця);
      } інакше якщо слово.вид == ВидСловаСимволВідкритаДужка {
        вивести_ю8(ю8"СимволВідкритаДужка");
        вивести_ю8(ю8" ");
        вивести_п64(слово.позиція_початку);
        вивести_ю8(ю8" ");
        надрукувати_п64(слово.позиція_кінця);
      } інакше якщо слово.вид == ВидСловаСимволЗакритаДужка {
        вивести_ю8(ю8"СимволЗакритаДужка");
        вивести_ю8(ю8" ");
        вивести_п64(слово.позиція_початку);
        вивести_ю8(ю8" ");
        надрукувати_п64(слово.позиція_кінця);
      } інакше якщо слово.вид == ВидСловаСимволКвадратнаВідкритаДужка {
        вивести_ю8(ю8"СимволКвадратнаВідкритаДужка");
        вивести_ю8(ю8" ");
        вивести_п64(слово.позиція_початку);
        вивести_ю8(ю8" ");
        надрукувати_п64(слово.позиція_кінця);
      } інакше якщо слово.вид == ВидСловаСимволКвадратнаЗакритаДужка {
        вивести_ю8(ю8"СимволКвадратнаЗакритаДужка");
        вивести_ю8(ю8" ");
        вивести_п64(слово.позиція_початку);
        вивести_ю8(ю8" ");
        надрукувати_п64(слово.позиція_кінця);
      } інакше якщо слово.вид == ВидСловаСимволЗнакПитання {
        вивести_ю8(ю8"СимволЗнакПитання");
        вивести_ю8(ю8" ");
        вивести_п64(слово.позиція_початку);
        вивести_ю8(ю8" ");
        надрукувати_п64(слово.позиція_кінця);
      } інакше якщо слово.вид == ВидСловаСимволДвокрапка {
        вивести_ю8(ю8"СимволДвокрапка");
        вивести_ю8(ю8" ");
        вивести_п64(слово.позиція_початку);
        вивести_ю8(ю8" ");
        надрукувати_п64(слово.позиція_кінця);
      } інакше якщо слово.вид == ВидСловаСимволТильда {
        вивести_ю8(ю8"СимволТильда");
        вивести_ю8(ю8" ");
        вивести_п64(слово.позиція_початку);
        вивести_ю8(ю8" ");
        надрукувати_п64(слово.позиція_кінця);
      } інакше якщо слово.вид == ВидСловаСимволОднолапка {
        вивести_ю8(ю8"СимволОднолапка");
        вивести_ю8(ю8" ");
        вивести_п64(слово.позиція_початку);
        вивести_ю8(ю8" ");
        надрукувати_п64(слово.позиція_кінця);
      } інакше якщо слово.вид == ВидСловаСимволДволапка {
        вивести_ю8(ю8"СимволДволапка");
        вивести_ю8(ю8" ");
        вивести_п64(слово.позиція_початку);
        вивести_ю8(ю8" ");
        надрукувати_п64(слово.позиція_кінця);
      } інакше якщо слово.вид == ВидСловаСимволЗнакОклику {
        вивести_ю8(ю8"СимволЗнакОклику");
        вивести_ю8(ю8" ");
        вивести_п64(слово.позиція_початку);
        вивести_ю8(ю8" ");
        надрукувати_п64(слово.позиція_кінця);
      } інакше якщо слово.вид == ВидСловаСимволКома {
        вивести_ю8(ю8"СимволКома");
        вивести_ю8(ю8" ");
        вивести_п64(слово.позиція_початку);
        вивести_ю8(ю8" ");
        надрукувати_п64(слово.позиція_кінця);
      } інакше якщо слово.вид == ВидСловаЧисло {
        вивести_ю8(ю8"Число");
        вивести_ю8(ю8" ");
        вивести_п64(слово.позиція_початку);
        вивести_ю8(ю8" ");
        надрукувати_п64(слово.позиція_кінця);
      } інакше якщо слово.вид == ВидСловаДесятковеЧисло {
        вивести_ю8(ю8"ДесятковеЧисло");
        вивести_ю8(ю8" ");
        вивести_п64(слово.позиція_початку);
        вивести_ю8(ю8" ");
        надрукувати_п64(слово.позиція_кінця);
      } інакше якщо слово.вид == ВидСловаСимвол {
        вивести_ю8(ю8"Символ");
        вивести_ю8(ю8" ");
        вивести_п64(слово.позиція_початку);
        вивести_ю8(ю8" ");
        надрукувати_п64(слово.позиція_кінця);
      } інакше якщо слово.вид == ВидСловаТекст {
        вивести_ю8(ю8"Текст");
        вивести_ю8(ю8" ");
        вивести_п64(слово.позиція_початку);
        вивести_ю8(ю8" ");
        надрукувати_п64(слово.позиція_кінця);
      } інакше якщо слово.вид == ВидСловаБагаторядковийТекст {
        вивести_ю8(ю8"БагаторядковийТекст");
        вивести_ю8(ю8" ");
        вивести_п64(слово.позиція_початку);
        вивести_ю8(ю8" ");
        надрукувати_п64(слово.позиція_кінця);
      } інакше якщо слово.вид == ВидСловаКоментар {
        вивести_ю8(ю8"Коментар");
        вивести_ю8(ю8" ");
        вивести_п64(слово.позиція_початку);
        вивести_ю8(ю8" ");
        надрукувати_п64(слово.позиція_кінця);
      } інакше якщо слово.вид == ВидСловаБагаторядковийКоментар {
        вивести_ю8(ю8"БагаторядковийКоментар");
        вивести_ю8(ю8" ");
        вивести_п64(слово.позиція_початку);
        вивести_ю8(ю8" ");
        надрукувати_п64(слово.позиція_кінця);
      } інакше якщо слово.вид == ВидСловаСимволМіжряд {
        вивести_ю8(ю8"СимволМіжряд");
        вивести_ю8(ю8" ");
        вивести_п64(слово.позиція_початку);
        вивести_ю8(ю8" ");
        надрукувати_п64(слово.позиція_кінця);
      } інакше якщо слово.вид == ВидСловаІдентифікатор {
        вивести_ю8(ю8"Ідентифікатор");
        вивести_ю8(ю8" ");
        вивести_п64(слово.позиція_початку);
        вивести_ю8(ю8" ");
        надрукувати_п64(слово.позиція_кінця);
      } інакше якщо слово.вид == ВидСловаКІНЕЦЬСЛІВ {
        вивести_ю8(ю8"КІНЕЦЬСЛІВ");
        вивести_ю8(ю8" ");
        вивести_п64(слово.позиція_початку);
        вивести_ю8(ю8" ");
        надрукувати_п64(слово.позиція_кінця);
      } інакше {
        надрукувати_ю8(ю8"НЕВІДОМЕ_СЛОВО");
      }
      п += 1;
    }
  }

  дія перевірити_чи_початок_ідентифікатора(текст_коду: адреса<ТекстКоду>, позиція_початку: позитивне, вихід_позиції_кінця: адреса<позитивне>): логічне;
  дія перевірити_чи_продовження_ідентифікатора(текст_коду: адреса<ТекстКоду>, позиція_початку: позитивне, вихід_позиції_кінця: адреса<позитивне>): логічне;
  дія перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду: адреса<ТекстКоду>, позиція_початку: позитивне, значення: ю8, вихід_позиції_кінця: адреса<позитивне>): логічне;
  дія перевірити_чи_текст_коду_має_ідентифікатор_за_позицією_початку(текст_коду: адреса<ТекстКоду>, позиція_початку: позитивне, вихід_позиції_кінця: адреса<позитивне>): логічне;

  дія перевірити_чи_початок_ідентифікатора(текст_коду: адреса<ТекстКоду>, позиція_початку: позитивне, вихід_позиції_кінця: адреса<позитивне>): логічне {
    якщо позиція_початку >= текст_коду.значення.розмір {
      вернути ні;
    }
    якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"а", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"б", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"в", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"г", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"д", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"е", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"є", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"ж", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"з", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"и", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"і", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"ї", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"й", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"к", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"л", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"м", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"н", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"о", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"п", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"р", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"с", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"т", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"у", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"ф", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"х", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"ц", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"ч", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"ш", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"щ", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"ь", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"ю", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"я", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"ґ", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"А", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"Б", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"В", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"Г", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"Д", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"Е", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"Є", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"Ж", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"З", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"И", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"І", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"Ї", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"Й", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"К", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"Л", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"М", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"Н", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"О", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"П", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"Р", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"С", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"Т", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"У", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"Ф", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"Х", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"Ц", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"Ч", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"Ш", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"Щ", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"Ь", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"Ю", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"Я", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"Ґ", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"_", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"ʼ", вихід_позиції_кінця) {
    } інакше {
      вернути ні;
    }
    вернути так;
  }

  дія перевірити_чи_продовження_ідентифікатора(текст_коду: адреса<ТекстКоду>, позиція_початку: позитивне, вихід_позиції_кінця: адреса<позитивне>): логічне {
    якщо позиція_початку >= текст_коду.значення.розмір {
      вернути ні;
    }
    якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"а", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"б", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"в", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"г", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"д", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"е", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"є", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"ж", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"з", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"и", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"і", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"ї", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"й", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"к", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"л", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"м", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"н", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"о", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"п", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"р", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"с", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"т", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"у", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"ф", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"х", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"ц", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"ч", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"ш", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"щ", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"ь", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"ю", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"я", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"ґ", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"А", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"Б", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"В", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"Г", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"Д", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"Е", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"Є", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"Ж", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"З", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"И", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"І", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"Ї", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"Й", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"К", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"Л", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"М", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"Н", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"О", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"П", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"Р", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"С", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"Т", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"У", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"Ф", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"Х", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"Ц", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"Ч", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"Ш", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"Щ", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"Ь", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"Ю", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"Я", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"Ґ", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"_", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"ʼ", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"0", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"1", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"2", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"3", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"4", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"5", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"6", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"7", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"8", вихід_позиції_кінця) {
    } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, позиція_початку, ю8"9", вихід_позиції_кінця) {
    } інакше {
      вернути ні;
    }
    вернути так;
  }

  дія перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду: адреса<ТекстКоду>, позиція_початку: позитивне, значення: ю8, вихід_позиції_кінця: адреса<позитивне>): логічне {
    якщо позиція_початку >= текст_коду.значення.розмір {
      вернути ні;
    }
    змінна ціль п: позитивне = 0;
    поки п < значення.розмір {
      якщо (позиція_початку + п) >= текст_коду.значення.розмір {
        вернути ні;
      }
      якщо текст_коду.значення.дані[позиція_початку + п] != значення.дані[п] {
        вернути ні;
      }
      вихід_позиції_кінця::вміст = позиція_початку + п;
      п += 1;
    }
    вернути так;
  }

  дія перевірити_чи_текст_коду_має_ключове_слово_ю8_за_позицією_початку(текст_коду: адреса<ТекстКоду>, позиція_початку: позитивне, значення: ю8, вихід_позиції_кінця: адреса<позитивне>, вихід_це_ідентифікатор: адреса<логічне>): логічне {
    якщо позиція_початку >= текст_коду.значення.розмір {
      вернути ні;
    }
    змінна ціль п: позитивне = 0;
    поки п < значення.розмір {
      якщо (позиція_початку + п) >= текст_коду.значення.розмір {
        вернути ні;
      }
      якщо текст_коду.значення.дані[позиція_початку + п] != значення.дані[п] {
        вернути ні;
      }
      вихід_позиції_кінця::вміст = позиція_початку + п;
      п += 1;
    }
    якщо (позиція_початку + п) >= текст_коду.значення.розмір {
      вернути так;
    }
    змінна ціль пкп: позитивне = 0;
    якщо перевірити_чи_продовження_ідентифікатора(текст_коду, позиція_початку + п, пкп::адреса) {
      вихід_це_ідентифікатор::вміст = так;
      вернути ні;
    }
    вернути так;
  }

  дія перевірити_чи_число(текст_коду: адреса<ТекстКоду>, позиція_початку: позитивне, вихід_позиції_кінця: адреса<позитивне>, вихід_чи_десяткове: адреса<логічне>): логічне {
    змінна ціль має_крапку: логічне = ні;
    змінна ціль має_символ_після_крапки: логічне = ні;
    змінна ціль п: позитивне = позиція_початку;
    якщо п >= текст_коду.значення.розмір {
      вернути ні;
    }
    якщо текст_коду.значення.дані[п] == UNICODE_0 {
      п += 1;
      якщо п < текст_коду.значення.розмір {
        якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, п, ю8"ш", п::адреса) {
          // потім: перевірка 0ш
        } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, п, ю8"Ш", п::адреса) {
          // потім: перевірка 0ш
        } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, п, ю8"д", п::адреса) {
          // потім: перевірка 0д
        } інакше якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, п, ю8"Д", п::адреса) {
          // потім: перевірка 0д
        }
      } інакше {
        стрибнути перевірка_продовження_числа;
      }
    }
    якщо текст_коду.значення.дані[п] == UNICODE_1 {
      п += 1;
      стрибнути перевірка_продовження_числа;
    }
    якщо текст_коду.значення.дані[п] == UNICODE_2 {
      п += 1;
      стрибнути перевірка_продовження_числа;
    }
    якщо текст_коду.значення.дані[п] == UNICODE_3 {
      п += 1;
      стрибнути перевірка_продовження_числа;
    }
    якщо текст_коду.значення.дані[п] == UNICODE_4 {
      п += 1;
      стрибнути перевірка_продовження_числа;
    }
    якщо текст_коду.значення.дані[п] == UNICODE_5 {
      п += 1;
      стрибнути перевірка_продовження_числа;
    }
    якщо текст_коду.значення.дані[п] == UNICODE_6 {
      п += 1;
      стрибнути перевірка_продовження_числа;
    }
    якщо текст_коду.значення.дані[п] == UNICODE_7 {
      п += 1;
      стрибнути перевірка_продовження_числа;
    }
    якщо текст_коду.значення.дані[п] == UNICODE_8 {
      п += 1;
      стрибнути перевірка_продовження_числа;
    }
    якщо текст_коду.значення.дані[п] == UNICODE_9 {
      п += 1;
      стрибнути перевірка_продовження_числа;
    }
    вернути ні;
    перевірка_продовження_числа:
    якщо п >= текст_коду.значення.розмір {
      вихід_позиції_кінця::вміст = п - 1;
      вихід_чи_десяткове::вміст = має_крапку;
      вернути так;
    }
    якщо текст_коду.значення.дані[п] == UNICODE_DOT {
      якщо текст_коду.значення.розмір > п + 1 {
        якщо текст_коду.значення.дані[п + 1] == UNICODE_DOT {
          вихід_позиції_кінця::вміст = п - 1;
          вихід_чи_десяткове::вміст = має_крапку;
          вернути так;
        }
      }
      якщо має_крапку {
        вернути ні;
      } інакше {
        має_крапку = так;
        п += 1;
        стрибнути перевірка_продовження_числа;
      }
    }
    якщо текст_коду.значення.дані[п] == UNICODE_0 {
      має_символ_після_крапки = так;
      п += 1;
      стрибнути перевірка_продовження_числа;
    }
    якщо текст_коду.значення.дані[п] == UNICODE_1 {
      має_символ_після_крапки = так;
      п += 1;
      стрибнути перевірка_продовження_числа;
    }
    якщо текст_коду.значення.дані[п] == UNICODE_2 {
      має_символ_після_крапки = так;
      п += 1;
      стрибнути перевірка_продовження_числа;
    }
    якщо текст_коду.значення.дані[п] == UNICODE_3 {
      має_символ_після_крапки = так;
      п += 1;
      стрибнути перевірка_продовження_числа;
    }
    якщо текст_коду.значення.дані[п] == UNICODE_4 {
      має_символ_після_крапки = так;
      п += 1;
      стрибнути перевірка_продовження_числа;
    }
    якщо текст_коду.значення.дані[п] == UNICODE_5 {
      має_символ_після_крапки = так;
      п += 1;
      стрибнути перевірка_продовження_числа;
    }
    якщо текст_коду.значення.дані[п] == UNICODE_6 {
      має_символ_після_крапки = так;
      п += 1;
      стрибнути перевірка_продовження_числа;
    }
    якщо текст_коду.значення.дані[п] == UNICODE_7 {
      має_символ_після_крапки = так;
      п += 1;
      стрибнути перевірка_продовження_числа;
    }
    якщо текст_коду.значення.дані[п] == UNICODE_8 {
      має_символ_після_крапки = так;
      п += 1;
      стрибнути перевірка_продовження_числа;
    }
    якщо текст_коду.значення.дані[п] == UNICODE_9 {
      має_символ_після_крапки = так;
      п += 1;
      стрибнути перевірка_продовження_числа;
    }
    якщо має_крапку {
      якщо має_символ_після_крапки {
        вихід_позиції_кінця::вміст = п - 1;
        вихід_чи_десяткове::вміст = так;
        вернути так;
      } інакше {
        вернути ні;
      }
    }
    вихід_позиції_кінця::вміст = п - 1;
    вихід_чи_десяткове::вміст = ні;
    вернути так;
  }

  дія перевірити_чи_текст_коду_має_ідентифікатор_за_позицією_початку(текст_коду: адреса<ТекстКоду>, позиція_початку: позитивне, вихід_позиції_кінця: адреса<позитивне>): логічне {
    якщо позиція_початку >= текст_коду.значення.розмір {
      вернути ні;
    }
    змінна ціль п: позитивне = позиція_початку;
    змінна ціль позиція_кінця: позитивне = 0;
    якщо перевірити_чи_початок_ідентифікатора(текст_коду, п, позиція_кінця::адреса) {
    } інакше {
      вернути ні;
    }
    п = позиція_кінця;
    п += 1;
    змінна ціль є_продовження: логічне = так;
    поки є_продовження {
      якщо перевірити_чи_продовження_ідентифікатора(текст_коду, п, позиція_кінця::адреса) {
        п = позиція_кінця;
        п += 1;
      } інакше {
        є_продовження = ні;
      }
    }
    вихід_позиції_кінця::вміст = п - 1;
    вернути так;
  }

  дія розібрати_на_слова(текст_коду: адреса<ТекстКоду>, вихід: адреса<Накопичувач<Слово>>): логічне {
    ціль слова = зробити_накопичувач<Слово>();

    змінна ціль п: позитивне = 0;
    поки п < текст_коду.значення.розмір {
      якщо текст_коду.значення.дані[п] == UNICODE_SPACE {
        стрибнути далі;
      }
      змінна ціль позиція_кінця: позитивне = 0;
      змінна ціль це_ідентифікатор: логічне = ні;
      якщо перевірити_чи_текст_коду_має_ключове_слово_ю8_за_позицією_початку(текст_коду, п, ю8"кінець", позиція_кінця::адреса, це_ідентифікатор::адреса) {
        покласти_в_накопичувач<Слово>(слова::адреса, Слово {
          вид = ВидСловаКінець,
          позиція_початку = п,
          позиція_кінця = позиція_кінця
        });
        п = позиція_кінця;
        стрибнути далі;
      }
      якщо це_ідентифікатор {
        стрибнути перевірка_ідентифікатора;
      }
      якщо перевірити_чи_текст_коду_має_ключове_слово_ю8_за_позицією_початку(текст_коду, п, ю8"дія", позиція_кінця::адреса, це_ідентифікатор::адреса) {
        покласти_в_накопичувач<Слово>(слова::адреса, Слово {
          вид = ВидСловаДія,
          позиція_початку = п,
          позиція_кінця = позиція_кінця
        });
        п = позиція_кінця;
        стрибнути далі;
      }
      якщо це_ідентифікатор {
        стрибнути перевірка_ідентифікатора;
      }
      якщо перевірити_чи_текст_коду_має_ключове_слово_ю8_за_позицією_початку(текст_коду, п, ю8"структура", позиція_кінця::адреса, це_ідентифікатор::адреса) {
        покласти_в_накопичувач<Слово>(слова::адреса, Слово {
          вид = ВидСловаСтруктура,
          позиція_початку = п,
          позиція_кінця = позиція_кінця
        });
        п = позиція_кінця;
        стрибнути далі;
      }
      якщо це_ідентифікатор {
        стрибнути перевірка_ідентифікатора;
      }
      якщо перевірити_чи_текст_коду_має_ключове_слово_ю8_за_позицією_початку(текст_коду, п, ю8"перебрати", позиція_кінця::адреса, це_ідентифікатор::адреса) {
        покласти_в_накопичувач<Слово>(слова::адреса, Слово {
          вид = ВидСловаПеребрати,
          позиція_початку = п,
          позиція_кінця = позиція_кінця
        });
        п = позиція_кінця;
        стрибнути далі;
      }
      якщо це_ідентифікатор {
        стрибнути перевірка_ідентифікатора;
      }
      якщо перевірити_чи_текст_коду_має_ключове_слово_ю8_за_позицією_початку(текст_коду, п, ю8"цикл", позиція_кінця::адреса, це_ідентифікатор::адреса) {
        покласти_в_накопичувач<Слово>(слова::адреса, Слово {
          вид = ВидСловаЦикл,
          позиція_початку = п,
          позиція_кінця = позиція_кінця
        });
        п = позиція_кінця;
        стрибнути далі;
      }
      якщо це_ідентифікатор {
        стрибнути перевірка_ідентифікатора;
      }
      якщо перевірити_чи_текст_коду_має_ключове_слово_ю8_за_позицією_початку(текст_коду, п, ю8"як", позиція_кінця::адреса, це_ідентифікатор::адреса) {
        покласти_в_накопичувач<Слово>(слова::адреса, Слово {
          вид = ВидСловаЯк,
          позиція_початку = п,
          позиція_кінця = позиція_кінця
        });
        п = позиція_кінця;
        стрибнути далі;
      }
      якщо перевірити_чи_текст_коду_має_ключове_слово_ю8_за_позицією_початку(текст_коду, п, ю8"якщо", позиція_кінця::адреса, це_ідентифікатор::адреса) {
        покласти_в_накопичувач<Слово>(слова::адреса, Слово {
          вид = ВидСловаЯкщо,
          позиція_початку = п,
          позиція_кінця = позиція_кінця
        });
        п = позиція_кінця;
        стрибнути далі;
      }
      якщо це_ідентифікатор {
        стрибнути перевірка_ідентифікатора;
      }
      якщо перевірити_чи_текст_коду_має_ключове_слово_ю8_за_позицією_початку(текст_коду, п, ю8"чекати", позиція_кінця::адреса, це_ідентифікатор::адреса) {
        покласти_в_накопичувач<Слово>(слова::адреса, Слово {
          вид = ВидСловаЧекати,
          позиція_початку = п,
          позиція_кінця = позиція_кінця
        });
        п = позиція_кінця;
        стрибнути далі;
      }
      якщо це_ідентифікатор {
        стрибнути перевірка_ідентифікатора;
      }
      якщо перевірити_чи_текст_коду_має_ключове_слово_ю8_за_позицією_початку(текст_коду, п, ю8"взяти", позиція_кінця::адреса, це_ідентифікатор::адреса) {
        покласти_в_накопичувач<Слово>(слова::адреса, Слово {
          вид = ВидСловаВзяти,
          позиція_початку = п,
          позиція_кінця = позиція_кінця
        });
        п = позиція_кінця;
        стрибнути далі;
      }
      якщо це_ідентифікатор {
        стрибнути перевірка_ідентифікатора;
      }
      якщо перевірити_чи_текст_коду_має_ключове_слово_ю8_за_позицією_початку(текст_коду, п, ю8"дати", позиція_кінця::адреса, це_ідентифікатор::адреса) {
        покласти_в_накопичувач<Слово>(слова::адреса, Слово {
          вид = ВидСловаДати,
          позиція_початку = п,
          позиція_кінця = позиція_кінця
        });
        п = позиція_кінця;
        стрибнути далі;
      }
      якщо це_ідентифікатор {
        стрибнути перевірка_ідентифікатора;
      }
      якщо перевірити_чи_текст_коду_має_ключове_слово_ю8_за_позицією_початку(текст_коду, п, ю8"є", позиція_кінця::адреса, це_ідентифікатор::адреса) {
        покласти_в_накопичувач<Слово>(слова::адреса, Слово {
          вид = ВидСловаЄ,
          позиція_початку = п,
          позиція_кінця = позиція_кінця
        });
        п = позиція_кінця;
        стрибнути далі;
      }
      якщо це_ідентифікатор {
        стрибнути перевірка_ідентифікатора;
      }
      якщо перевірити_чи_текст_коду_має_ключове_слово_ю8_за_позицією_початку(текст_коду, п, ю8"спец", позиція_кінця::адреса, це_ідентифікатор::адреса) {
        покласти_в_накопичувач<Слово>(слова::адреса, Слово {
          вид = ВидСловаСпец,
          позиція_початку = п,
          позиція_кінця = позиція_кінця
        });
        п = позиція_кінця;
        стрибнути далі;
      }
      якщо це_ідентифікатор {
        стрибнути перевірка_ідентифікатора;
      }
      якщо перевірити_чи_текст_коду_має_ключове_слово_ю8_за_позицією_початку(текст_коду, п, ю8"вернути", позиція_кінця::адреса, це_ідентифікатор::адреса) {
        покласти_в_накопичувач<Слово>(слова::адреса, Слово {
          вид = ВидСловаВернути,
          позиція_початку = п,
          позиція_кінця = позиція_кінця
        });
        п = позиція_кінця;
        стрибнути далі;
      }
      якщо це_ідентифікатор {
        стрибнути перевірка_ідентифікатора;
      }
      якщо перевірити_чи_текст_коду_має_ключове_слово_ю8_за_позицією_початку(текст_коду, п, ю8"тривала", позиція_кінця::адреса, це_ідентифікатор::адреса) {
        покласти_в_накопичувач<Слово>(слова::адреса, Слово {
          вид = ВидСловаТривала,
          позиція_початку = п,
          позиція_кінця = позиція_кінця
        });
        п = позиція_кінця;
        стрибнути далі;
      }
      якщо це_ідентифікатор {
        стрибнути перевірка_ідентифікатора;
      }
      якщо перевірити_чи_текст_коду_має_ключове_слово_ю8_за_позицією_початку(текст_коду, п, ю8"власна", позиція_кінця::адреса, це_ідентифікатор::адреса) {
        покласти_в_накопичувач<Слово>(слова::адреса, Слово {
          вид = ВидСловаВласна,
          позиція_початку = п,
          позиція_кінця = позиція_кінця
        });
        п = позиція_кінця;
        стрибнути далі;
      }
      якщо це_ідентифікатор {
        стрибнути перевірка_ідентифікатора;
      }
      якщо перевірити_чи_текст_коду_має_ключове_слово_ю8_за_позицією_початку(текст_коду, п, ю8"і", позиція_кінця::адреса, це_ідентифікатор::адреса) {
        покласти_в_накопичувач<Слово>(слова::адреса, Слово {
          вид = ВидСловаІ,
          позиція_початку = п,
          позиція_кінця = позиція_кінця
        });
        п = позиція_кінця;
        стрибнути далі;
      }
      якщо перевірити_чи_текст_коду_має_ключове_слово_ю8_за_позицією_початку(текст_коду, п, ю8"інакше", позиція_кінця::адреса, це_ідентифікатор::адреса) {
        покласти_в_накопичувач<Слово>(слова::адреса, Слово {
          вид = ВидСловаІнакше,
          позиція_початку = п,
          позиція_кінця = позиція_кінця
        });
        п = позиція_кінця;
        стрибнути далі;
      }
      якщо це_ідентифікатор {
        стрибнути перевірка_ідентифікатора;
      }
      якщо перевірити_чи_текст_коду_має_ключове_слово_ю8_за_позицією_початку(текст_коду, п, ю8"або", позиція_кінця::адреса, це_ідентифікатор::адреса) {
        покласти_в_накопичувач<Слово>(слова::адреса, Слово {
          вид = ВидСловаАбо,
          позиція_початку = п,
          позиція_кінця = позиція_кінця
        });
        п = позиція_кінця;
        стрибнути далі;
      }
      якщо це_ідентифікатор {
        стрибнути перевірка_ідентифікатора;
      }
      якщо перевірити_чи_текст_коду_має_ключове_слово_ю8_за_позицією_початку(текст_коду, п, ю8"спробувати", позиція_кінця::адреса, це_ідентифікатор::адреса) {
        покласти_в_накопичувач<Слово>(слова::адреса, Слово {
          вид = ВидСловаСпробувати,
          позиція_початку = п,
          позиція_кінця = позиція_кінця
        });
        п = позиція_кінця;
        стрибнути далі;
      }
      якщо це_ідентифікатор {
        стрибнути перевірка_ідентифікатора;
      }
      якщо перевірити_чи_текст_коду_має_ключове_слово_ю8_за_позицією_початку(текст_коду, п, ю8"зловити", позиція_кінця::адреса, це_ідентифікатор::адреса) {
        покласти_в_накопичувач<Слово>(слова::адреса, Слово {
          вид = ВидСловаЗловити,
          позиція_початку = п,
          позиція_кінця = позиція_кінця
        });
        п = позиція_кінця;
        стрибнути далі;
      }
      якщо це_ідентифікатор {
        стрибнути перевірка_ідентифікатора;
      }
      якщо перевірити_чи_текст_коду_має_ключове_слово_ю8_за_позицією_початку(текст_коду, п, ю8"впасти", позиція_кінця::адреса, це_ідентифікатор::адреса) {
        покласти_в_накопичувач<Слово>(слова::адреса, Слово {
          вид = ВидСловаВпасти,
          позиція_початку = п,
          позиція_кінця = позиція_кінця
        });
        п = позиція_кінця;
        стрибнути далі;
      }
      якщо це_ідентифікатор {
        стрибнути перевірка_ідентифікатора;
      }
      якщо перевірити_чи_текст_коду_має_ключове_слово_ю8_за_позицією_початку(текст_коду, п, ю8"поки", позиція_кінця::адреса, це_ідентифікатор::адреса) {
        покласти_в_накопичувач<Слово>(слова::адреса, Слово {
          вид = ВидСловаПоки,
          позиція_початку = п,
          позиція_кінця = позиція_кінця
        });
        п = позиція_кінця;
        стрибнути далі;
      }
      якщо це_ідентифікатор {
        стрибнути перевірка_ідентифікатора;
      }
      якщо перевірити_чи_текст_коду_має_ключове_слово_ю8_за_позицією_початку(текст_коду, п, ю8"модуль", позиція_кінця::адреса, це_ідентифікатор::адреса) {
        покласти_в_накопичувач<Слово>(слова::адреса, Слово {
          вид = ВидСловаМодуль,
          позиція_початку = п,
          позиція_кінця = позиція_кінця
        });
        п = позиція_кінця;
        стрибнути далі;
      }
      якщо це_ідентифікатор {
        стрибнути перевірка_ідентифікатора;
      }
      якщо перевірити_чи_текст_коду_має_ключове_слово_ю8_за_позицією_початку(текст_коду, п, ю8"рівно", позиція_кінця::адреса, це_ідентифікатор::адреса) {
        покласти_в_накопичувач<Слово>(слова::адреса, Слово {
          вид = ВидСловаРівно,
          позиція_початку = п,
          позиція_кінця = позиція_кінця
        });
        п = позиція_кінця;
        стрибнути далі;
      }
      якщо це_ідентифікатор {
        стрибнути перевірка_ідентифікатора;
      }
      якщо перевірити_чи_текст_коду_має_ключове_слово_ю8_за_позицією_початку(текст_коду, п, ю8"більше", позиція_кінця::адреса, це_ідентифікатор::адреса) {
        покласти_в_накопичувач<Слово>(слова::адреса, Слово {
          вид = ВидСловаБільше,
          позиція_початку = п,
          позиція_кінця = позиція_кінця
        });
        п = позиція_кінця;
        стрибнути далі;
      }
      якщо це_ідентифікатор {
        стрибнути перевірка_ідентифікатора;
      }
      якщо перевірити_чи_текст_коду_має_ключове_слово_ю8_за_позицією_початку(текст_коду, п, ю8"менше", позиція_кінця::адреса, це_ідентифікатор::адреса) {
        покласти_в_накопичувач<Слово>(слова::адреса, Слово {
          вид = ВидСловаМенше,
          позиція_початку = п,
          позиція_кінця = позиція_кінця
        });
        п = позиція_кінця;
        стрибнути далі;
      }
      якщо це_ідентифікатор {
        стрибнути перевірка_ідентифікатора;
      }
      якщо перевірити_чи_текст_коду_має_ключове_слово_ю8_за_позицією_початку(текст_коду, п, ю8"містить", позиція_кінця::адреса, це_ідентифікатор::адреса) {
        покласти_в_накопичувач<Слово>(слова::адреса, Слово {
          вид = ВидСловаМістить,
          позиція_початку = п,
          позиція_кінця = позиція_кінця
        });
        п = позиція_кінця;
        стрибнути далі;
      }
      якщо це_ідентифікатор {
        стрибнути перевірка_ідентифікатора;
      }
      якщо перевірити_чи_текст_коду_має_ключове_слово_ю8_за_позицією_початку(текст_коду, п, ю8"не", позиція_кінця::адреса, це_ідентифікатор::адреса) {
        покласти_в_накопичувач<Слово>(слова::адреса, Слово {
          вид = ВидСловаНе,
          позиція_початку = п,
          позиція_кінця = позиція_кінця
        });
        п = позиція_кінця;
        стрибнути далі;
      }
      якщо це_ідентифікатор {
        стрибнути перевірка_ідентифікатора;
      }
      якщо перевірити_чи_текст_коду_має_ключове_слово_ю8_за_позицією_початку(текст_коду, п, ю8"предок", позиція_кінця::адреса, це_ідентифікатор::адреса) {
        покласти_в_накопичувач<Слово>(слова::адреса, Слово {
          вид = ВидСловаПредок,
          позиція_початку = п,
          позиція_кінця = позиція_кінця
        });
        п = позиція_кінця;
        стрибнути далі;
      }
      якщо це_ідентифікатор {
        стрибнути перевірка_ідентифікатора;
      }
      якщо перевірити_чи_текст_коду_має_ключове_слово_ю8_за_позицією_початку(текст_коду, п, ю8"це", позиція_кінця::адреса, це_ідентифікатор::адреса) {
        покласти_в_накопичувач<Слово>(слова::адреса, Слово {
          вид = ВидСловаЦе,
          позиція_початку = п,
          позиція_кінця = позиція_кінця
        });
        п = позиція_кінця;
        стрибнути далі;
      }
      якщо це_ідентифікатор {
        стрибнути перевірка_ідентифікатора;
      }
      якщо перевірити_чи_текст_коду_має_ключове_слово_ю8_за_позицією_початку(текст_коду, п, ю8"перелік", позиція_кінця::адреса, це_ідентифікатор::адреса) {
        покласти_в_накопичувач<Слово>(слова::адреса, Слово {
          вид = ВидСловаПерелік,
          позиція_початку = п,
          позиція_кінця = позиція_кінця
        });
        п = позиція_кінця;
        стрибнути далі;
      }
      якщо це_ідентифікатор {
        стрибнути перевірка_ідентифікатора;
      }
      якщо перевірити_чи_текст_коду_має_ключове_слово_ю8_за_позицією_початку(текст_коду, п, ю8"композиція", позиція_кінця::адреса, це_ідентифікатор::адреса) {
        покласти_в_накопичувач<Слово>(слова::адреса, Слово {
          вид = ВидСловаКомпозиція,
          позиція_початку = п,
          позиція_кінця = позиція_кінця
        });
        п = позиція_кінця;
        стрибнути далі;
      }
      якщо це_ідентифікатор {
        стрибнути перевірка_ідентифікатора;
      }
      якщо перевірити_чи_текст_коду_має_ключове_слово_ю8_за_позицією_початку(текст_коду, п, ю8"зовнішня", позиція_кінця::адреса, це_ідентифікатор::адреса) {
        покласти_в_накопичувач<Слово>(слова::адреса, Слово {
          вид = ВидСловаЗовнішня,
          позиція_початку = п,
          позиція_кінця = позиція_кінця
        });
        п = позиція_кінця;
        стрибнути далі;
      }
      якщо це_ідентифікатор {
        стрибнути перевірка_ідентифікатора;
      }
      якщо перевірити_чи_текст_коду_має_ключове_слово_ю8_за_позицією_початку(текст_коду, п, ю8"внутрішня", позиція_кінця::адреса, це_ідентифікатор::адреса) {
        покласти_в_накопичувач<Слово>(слова::адреса, Слово {
          вид = ВидСловаВнутрішня,
          позиція_початку = п,
          позиція_кінця = позиція_кінця
        });
        п = позиція_кінця;
        стрибнути далі;
      }
      якщо це_ідентифікатор {
        стрибнути перевірка_ідентифікатора;
      }
      якщо перевірити_чи_текст_коду_має_ключове_слово_ю8_за_позицією_початку(текст_коду, п, ю8"місцева", позиція_кінця::адреса, це_ідентифікатор::адреса) {
        покласти_в_накопичувач<Слово>(слова::адреса, Слово {
          вид = ВидСловаМісцева,
          позиція_початку = п,
          позиція_кінця = позиція_кінця
        });
        п = позиція_кінця;
        стрибнути далі;
      }
      якщо це_ідентифікатор {
        стрибнути перевірка_ідентифікатора;
      }
      якщо перевірити_чи_текст_коду_має_ключове_слово_ю8_за_позицією_початку(текст_коду, п, ю8"властивість", позиція_кінця::адреса, це_ідентифікатор::адреса) {
        покласти_в_накопичувач<Слово>(слова::адреса, Слово {
          вид = ВидСловаВластивість,
          позиція_початку = п,
          позиція_кінця = позиція_кінця
        });
        п = позиція_кінця;
        стрибнути далі;
      }
      якщо це_ідентифікатор {
        стрибнути перевірка_ідентифікатора;
      }
      якщо перевірити_чи_текст_коду_має_ключове_слово_ю8_за_позицією_початку(текст_коду, п, ю8"видалити", позиція_кінця::адреса, це_ідентифікатор::адреса) {
        покласти_в_накопичувач<Слово>(слова::адреса, Слово {
          вид = ВидСловаВидалити,
          позиція_початку = п,
          позиція_кінця = позиція_кінця
        });
        п = позиція_кінця;
        стрибнути далі;
      }
      якщо це_ідентифікатор {
        стрибнути перевірка_ідентифікатора;
      }
      якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, п, ю8"=", позиція_кінця::адреса) {
        покласти_в_накопичувач<Слово>(слова::адреса, Слово {
          вид = ВидСловаСимволРівно,
          позиція_початку = п,
          позиція_кінця = позиція_кінця
        });
        п = позиція_кінця;
        стрибнути далі;
      }
      якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, п, ю8">", позиція_кінця::адреса) {
        покласти_в_накопичувач<Слово>(слова::адреса, Слово {
          вид = ВидСловаСимволБільше,
          позиція_початку = п,
          позиція_кінця = позиція_кінця
        });
        п = позиція_кінця;
        стрибнути далі;
      }
      якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, п, ю8"<", позиція_кінця::адреса) {
        покласти_в_накопичувач<Слово>(слова::адреса, Слово {
          вид = ВидСловаСимволМенше,
          позиція_початку = п,
          позиція_кінця = позиція_кінця
        });
        п = позиція_кінця;
        стрибнути далі;
      }
      якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, п, ю8".", позиція_кінця::адреса) {
        покласти_в_накопичувач<Слово>(слова::адреса, Слово {
          вид = ВидСловаСимволКрапка,
          позиція_початку = п,
          позиція_кінця = позиція_кінця
        });
        п = позиція_кінця;
        стрибнути далі;
      }
      якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, п, ю8"+", позиція_кінця::адреса) {
        покласти_в_накопичувач<Слово>(слова::адреса, Слово {
          вид = ВидСловаСимволПлюс,
          позиція_початку = п,
          позиція_кінця = позиція_кінця
        });
        п = позиція_кінця;
        стрибнути далі;
      }
      якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, п, ю8"-", позиція_кінця::адреса) {
        покласти_в_накопичувач<Слово>(слова::адреса, Слово {
          вид = ВидСловаСимволМінус,
          позиція_початку = п,
          позиція_кінця = позиція_кінця
        });
        п = позиція_кінця;
        стрибнути далі;
      }
      якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, п, ю8"*", позиція_кінця::адреса) {
        покласти_в_накопичувач<Слово>(слова::адреса, Слово {
          вид = ВидСловаСимволПомножити,
          позиція_початку = п,
          позиція_кінця = позиція_кінця
        });
        п = позиція_кінця;
        стрибнути далі;
      }
      якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, п, ю8"/", позиція_кінця::адреса) {
        покласти_в_накопичувач<Слово>(слова::адреса, Слово {
          вид = ВидСловаСимволПоділити,
          позиція_початку = п,
          позиція_кінця = позиція_кінця
        });
        п = позиція_кінця;
        стрибнути далі;
      }
      якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, п, ю8"%", позиція_кінця::адреса) {
        покласти_в_накопичувач<Слово>(слова::адреса, Слово {
          вид = ВидСловаСимволЗалишку,
          позиція_початку = п,
          позиція_кінця = позиція_кінця
        });
        п = позиція_кінця;
        стрибнути далі;
      }
      якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, п, ю8"^", позиція_кінця::адреса) {
        покласти_в_накопичувач<Слово>(слова::адреса, Слово {
          вид = ВидСловаСимволПірамідка,
          позиція_початку = п,
          позиція_кінця = позиція_кінця
        });
        п = позиція_кінця;
        стрибнути далі;
      }
      якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, п, ю8"&", позиція_кінця::адреса) {
        покласти_в_накопичувач<Слово>(слова::адреса, Слово {
          вид = ВидСловаСимволІ,
          позиція_початку = п,
          позиція_кінця = позиція_кінця
        });
        п = позиція_кінця;
        стрибнути далі;
      }
      якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, п, ю8"|", позиція_кінця::адреса) {
        покласти_в_накопичувач<Слово>(слова::адреса, Слово {
          вид = ВидСловаСимволАбо,
          позиція_початку = п,
          позиція_кінця = позиція_кінця
        });
        п = позиція_кінця;
        стрибнути далі;
      }
      якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, п, ю8"(", позиція_кінця::адреса) {
        покласти_в_накопичувач<Слово>(слова::адреса, Слово {
          вид = ВидСловаСимволВідкритаДужка,
          позиція_початку = п,
          позиція_кінця = позиція_кінця
        });
        п = позиція_кінця;
        стрибнути далі;
      }
      якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, п, ю8")", позиція_кінця::адреса) {
        покласти_в_накопичувач<Слово>(слова::адреса, Слово {
          вид = ВидСловаСимволЗакритаДужка,
          позиція_початку = п,
          позиція_кінця = позиція_кінця
        });
        п = позиція_кінця;
        стрибнути далі;
      }
      якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, п, ю8"[", позиція_кінця::адреса) {
        покласти_в_накопичувач<Слово>(слова::адреса, Слово {
          вид = ВидСловаСимволКвадратнаВідкритаДужка,
          позиція_початку = п,
          позиція_кінця = позиція_кінця
        });
        п = позиція_кінця;
        стрибнути далі;
      }
      якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, п, ю8"]", позиція_кінця::адреса) {
        покласти_в_накопичувач<Слово>(слова::адреса, Слово {
          вид = ВидСловаСимволКвадратнаЗакритаДужка,
          позиція_початку = п,
          позиція_кінця = позиція_кінця
        });
        п = позиція_кінця;
        стрибнути далі;
      }
      якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, п, ю8"?", позиція_кінця::адреса) {
        покласти_в_накопичувач<Слово>(слова::адреса, Слово {
          вид = ВидСловаСимволЗнакПитання,
          позиція_початку = п,
          позиція_кінця = позиція_кінця
        });
        п = позиція_кінця;
        стрибнути далі;
      }
      якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, п, ю8":", позиція_кінця::адреса) {
        покласти_в_накопичувач<Слово>(слова::адреса, Слово {
          вид = ВидСловаСимволДвокрапка,
          позиція_початку = п,
          позиція_кінця = позиція_кінця
        });
        п = позиція_кінця;
        стрибнути далі;
      }
      якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, п, ю8"~", позиція_кінця::адреса) {
        покласти_в_накопичувач<Слово>(слова::адреса, Слово {
          вид = ВидСловаСимволТильда,
          позиція_початку = п,
          позиція_кінця = позиція_кінця
        });
        п = позиція_кінця;
        стрибнути далі;
      }
      якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, п, ю8"!", позиція_кінця::адреса) {
        покласти_в_накопичувач<Слово>(слова::адреса, Слово {
          вид = ВидСловаСимволЗнакОклику,
          позиція_початку = п,
          позиція_кінця = позиція_кінця
        });
        п = позиція_кінця;
        стрибнути далі;
      }
      якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, п, ю8",", позиція_кінця::адреса) {
        покласти_в_накопичувач<Слово>(слова::адреса, Слово {
          вид = ВидСловаСимволКома,
          позиція_початку = п,
          позиція_кінця = позиція_кінця
        });
        п = позиція_кінця;
        стрибнути далі;
      }
      якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, п, ю8"\n", позиція_кінця::адреса) {
        покласти_в_накопичувач<Слово>(слова::адреса, Слово {
          вид = ВидСловаСимволМіжряд,
          позиція_початку = п,
          позиція_кінця = позиція_кінця
        });
        п = позиція_кінця;
        стрибнути далі;
      }
      якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, п, ю8"'", позиція_кінця::адреса) {
        змінна ціль пп: позитивне = позиція_кінця + 1;
        змінна ціль закінчено: логічне = ні;
        поки пп < текст_коду.значення.розмір {
          якщо текст_коду.значення.дані[пп] == 39 {
            закінчено = так;
            стрибнути закінчити_перебір_символів;
          }
          якщо текст_коду.значення.дані[пп] == 10 {
            стрибнути закінчити_перебір_символів;
          }
          пп += 1;
        }
        закінчити_перебір_символів:
        якщо закінчено {
          покласти_в_накопичувач<Слово>(слова::адреса, Слово {
            вид = ВидСловаСимвол,
            позиція_початку = п,
            позиція_кінця = пп
          });
          п = пп;
          стрибнути далі;
        }
        вернути ні;
      }
      якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, п, ю8"\"\"\"", позиція_кінця::адреса) {
        змінна ціль пп: позитивне = позиція_кінця + 1;
        змінна ціль закінчено: логічне = ні;
        поки пп < текст_коду.значення.розмір {
          якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, пп, ю8"\"\"\"", пп::адреса) {
            закінчено = так;
            стрибнути закінчити_перебір_багаторядкового_тексту;
          }
          пп += 1;
        }
        закінчити_перебір_багаторядкового_тексту:
        якщо закінчено {
          покласти_в_накопичувач<Слово>(слова::адреса, Слово {
            вид = ВидСловаБагаторядковийТекст,
            позиція_початку = п,
            позиція_кінця = пп
          });
          п = пп;
          стрибнути далі;
        }
        вернути ні;
      }
      якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, п, ю8"\"", позиція_кінця::адреса) {
        змінна ціль пп: позитивне = позиція_кінця + 1;
        змінна ціль закінчено: логічне = ні;
        поки пп < текст_коду.значення.розмір {
          якщо текст_коду.значення.дані[пп] == 34 {
            закінчено = так;
            стрибнути закінчити_перебір_тексту;
          }
          якщо текст_коду.значення.дані[пп] == 10 {
            стрибнути закінчити_перебір_тексту;
          }
          пп += 1;
        }
        закінчити_перебір_тексту:
        якщо закінчено {
          покласти_в_накопичувач<Слово>(слова::адреса, Слово {
            вид = ВидСловаТекст,
            позиція_початку = п,
            позиція_кінця = пп
          });
          п = пп;
          стрибнути далі;
        }
        вернути ні;
      }
      якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, п, ю8";;", позиція_кінця::адреса) {
        змінна ціль пп: позитивне = позиція_кінця + 1;
        змінна ціль закінчено: логічне = ні;
        поки пп < текст_коду.значення.розмір {
          якщо текст_коду.значення.дані[пп] == 10 {
            закінчено = так;
            стрибнути закінчити_перебір_коментаря;
          }
          пп += 1;
        }
        закінчити_перебір_коментаря:
//        покласти_в_накопичувач<Слово>(слова::адреса, Слово {
//          вид = ВидСловаКоментар,
//          позиція_початку = п,
//          позиція_кінця = пп - 1
//        });
        якщо закінчено {
          покласти_в_накопичувач<Слово>(слова::адреса, Слово {
            вид = ВидСловаСимволМіжряд,
            позиція_початку = пп,
            позиція_кінця = пп
          });
        }
        п = пп;
        стрибнути далі;
      }
      якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, п, ю8";*", позиція_кінця::адреса) {
        змінна ціль пп: позитивне = позиція_кінця + 1;
        змінна ціль закінчено: логічне = ні;
        поки пп < текст_коду.значення.розмір {
          якщо перевірити_чи_текст_коду_має_ю8_за_позицією_початку(текст_коду, пп, ю8"*;", пп::адреса) {
            закінчено = так;
            стрибнути закінчити_перебір_багаторядкового_коментаря;
          }
          пп += 1;
        }
        закінчити_перебір_багаторядкового_коментаря:
        якщо закінчено {
//          покласти_в_накопичувач<Слово>(слова::адреса, Слово {
//            вид = ВидСловаБагаторядковийКоментар,
//            позиція_початку = п,
//            позиція_кінця = пп
//          });
          п = пп;
          стрибнути далі;
        }
        вернути ні;
      }
      змінна ціль чи_десяткове: логічне = ні;
      якщо перевірити_чи_число(текст_коду, п, позиція_кінця::адреса, чи_десяткове::адреса) {
        якщо чи_десяткове {
          покласти_в_накопичувач<Слово>(слова::адреса, Слово {
            вид = ВидСловаДесятковеЧисло,
            позиція_початку = п,
            позиція_кінця = позиція_кінця
          });
        } інакше {
          покласти_в_накопичувач<Слово>(слова::адреса, Слово {
            вид = ВидСловаЧисло,
            позиція_початку = п,
            позиція_кінця = позиція_кінця
          });
        }
        п = позиція_кінця;
        стрибнути далі;
      }
      перевірка_ідентифікатора:
      якщо перевірити_чи_текст_коду_має_ідентифікатор_за_позицією_початку(текст_коду, п, позиція_кінця::адреса) {
        покласти_в_накопичувач<Слово>(слова::адреса, Слово {
          вид = ВидСловаІдентифікатор,
          позиція_початку = п,
          позиція_кінця = позиція_кінця
        });
        п = позиція_кінця;
        стрибнути далі;
      }
      вернути ні;
      далі:
      п += 1;
    }
    покласти_в_накопичувач<Слово>(слова::адреса, Слово {
      вид = ВидСловаКІНЕЦЬСЛІВ,
      позиція_початку = п - 1,
      позиція_кінця = п - 1
    });

    вихід::вміст = слова;
    вернути так;
  }
}

секція мавка {
  дія спробувати_розібрати_частинку(слова: Накопичувач<Слово>, позиція_початку: позитивне, вихід: адреса<адреса<Гілка>>, вихід_позиції_кінця: адреса<позитивне>): логічне;
  дія спробувати_розібрати_атом(слова: Накопичувач<Слово>, позиція_початку: позитивне, вихід: адреса<адреса<Гілка>>, вихід_позиції_кінця: адреса<позитивне>): логічне;
  дія спробувати_розібрати_аргумент(слова: Накопичувач<Слово>, позиція_початку: позитивне, вихід: адреса<Аргумент>, вихід_позиції_кінця: адреса<позитивне>): логічне;
  дія спробувати_розібрати_молекулу(слова: Накопичувач<Слово>, позиція_початку: позитивне, вихід: адреса<адреса<Гілка>>, вихід_позиції_кінця: адреса<позитивне>): логічне;
  дія спробувати_розібрати_молекулу__хвіст(слова: Накопичувач<Слово>, позиція_початку: позитивне, вихід: адреса<адреса<Гілка>>, вихід_позиції_кінця: адреса<позитивне>, гілка_атома: адреса<Гілка>): логічне;
  дія спробувати_розібрати_значення(слова: Накопичувач<Слово>, позиція_початку: позитивне, вихід: адреса<адреса<Гілка>>, вихід_позиції_кінця: адреса<позитивне>): логічне;
  дія спробувати_розібрати_визначити(слова: Накопичувач<Слово>, позиція_початку: позитивне, вихід: адреса<адреса<Гілка>>, вихід_позиції_кінця: адреса<позитивне>): логічне;
  дія спробувати_розібрати_вернути(слова: Накопичувач<Слово>, позиція_початку: позитивне, вихід: адреса<адреса<Гілка>>, вихід_позиції_кінця: адреса<позитивне>): логічне;
  дія спробувати_розібрати_впасти(слова: Накопичувач<Слово>, позиція_початку: позитивне, вихід: адреса<адреса<Гілка>>, вихід_позиції_кінця: адреса<позитивне>): логічне;
  дія спробувати_розібрати_елемент_взяти(слова: Накопичувач<Слово>, позиція_початку: позитивне, вихід: адреса<ЕлементВзяти>, вихід_позиції_кінця: адреса<позитивне>): логічне;
  дія спробувати_розібрати_взяти(слова: Накопичувач<Слово>, позиція_початку: позитивне, вихід: адреса<адреса<Гілка>>, вихід_позиції_кінця: адреса<позитивне>): логічне;
  дія спробувати_розібрати_елемент_дати(слова: Накопичувач<Слово>, позиція_початку: позитивне, вихід: адреса<ЕлементДати>, вихід_позиції_кінця: адреса<позитивне>): логічне;
  дія спробувати_розібрати_дати(слова: Накопичувач<Слово>, позиція_початку: позитивне, вихід: адреса<адреса<Гілка>>, вихід_позиції_кінця: адреса<позитивне>): логічне;
  дія спробувати_розібрати_елемент_тіла(слова: Накопичувач<Слово>, позиція_початку: позитивне, вихід: адреса<адреса<Гілка>>, вихід_позиції_кінця: адреса<позитивне>): логічне;
  дія спробувати_розібрати_тіло(слова: Накопичувач<Слово>, позиція_початку: позитивне, вихід: адреса<СписокГілок>, вихід_позиції_кінця: адреса<позитивне>, вид_слова_закінчення: позитивне): логічне;
  дія спробувати_розібрати_тип(слова: Накопичувач<Слово>, позиція_початку: позитивне, вихід: адреса<Тип>, вихід_позиції_кінця: адреса<позитивне>): логічне;
  дія спробувати_розібрати_параметр(слова: Накопичувач<Слово>, позиція_початку: позитивне, вихід: адреса<Параметр>, вихід_позиції_кінця: адреса<позитивне>): логічне;
  дія спробувати_розібрати_дію(слова: Накопичувач<Слово>, позиція_початку: позитивне, вихід: адреса<адреса<Гілка>>, вихід_позиції_кінця: адреса<позитивне>): логічне;
  дія спробувати_розібрати_структуру(слова: Накопичувач<Слово>, позиція_початку: позитивне, вихід: адреса<адреса<Гілка>>, вихід_позиції_кінця: адреса<позитивне>): логічне;
  дія спробувати_розібрати_модуль(слова: Накопичувач<Слово>, позиція_початку: позитивне, вихід: адреса<адреса<Гілка>>, вихід_позиції_кінця: адреса<позитивне>): логічне;
  дія спробувати_розібрати_якщо(слова: Накопичувач<Слово>, позиція_початку: позитивне, вихід: адреса<адреса<Гілка>>, вихід_позиції_кінця: адреса<позитивне>): логічне;
  дія спробувати_розібрати_поки(слова: Накопичувач<Слово>, позиція_початку: позитивне, вихід: адреса<адреса<Гілка>>, вихід_позиції_кінця: адреса<позитивне>): логічне;
  дія спробувати_розібрати_цикл(слова: Накопичувач<Слово>, позиція_початку: позитивне, вихід: адреса<адреса<Гілка>>, вихід_позиції_кінця: адреса<позитивне>): логічне;
  дія спробувати_розібрати_перебрати(слова: Накопичувач<Слово>, позиція_початку: позитивне, вихід: адреса<адреса<Гілка>>, вихід_позиції_кінця: адреса<позитивне>): логічне;
  дія спробувати_розібрати_спробувати(слова: Накопичувач<Слово>, позиція_початку: позитивне, вихід: адреса<адреса<Гілка>>, вихід_позиції_кінця: адреса<позитивне>): логічне;

  дія спробувати_розібрати_частинку(слова: Накопичувач<Слово>, позиція_початку: позитивне, вихід: адреса<адреса<Гілка>>, вихід_позиції_кінця: адреса<позитивне>): логічне {
    змінна ціль п = позиція_початку;
    якщо слова.дані[п].вид == ВидСловаСимволВідкритаДужка {
      п += 1;
      змінна ціль гілка_гнізда: адреса<Гілка> = пусто;
      якщо спробувати_розібрати_молекулу(слова, п, гілка_гнізда::адреса, п::адреса) {
        п += 1;
        якщо слова.дані[п].вид == ВидСловаСимволЗакритаДужка {
          вихід::вміст = гілка_гнізда;
          вихід_позиції_кінця::вміст = п;
          вернути так;
        } інакше {
          звільнити_гілку(гілка_гнізда);
        }
      }
      вернути ні;
    }
    п = позиція_початку;
    якщо слова.дані[п].вид == ВидСловаІдентифікатор {
      ціль позиція_ідентифікатора = п;
      п += 1;
      якщо слова.дані[п].вид == ВидСловаТекст {
        змінна ціль гілка_тексту = виділити<Гілка>();
        гілка_тексту.вид = ВидГілкиТекст;
        гілка_тексту.дані = ДаніГілкиТекст {
          ідентифікатор = можливо<Ідентифікатор> { позитивне(так), Ідентифікатор { позиція_ідентифікатора } },
          позиція_слова = п
        };
        гілка_тексту.місцезнаходження = Місцезнаходження { позиція_ідентифікатора };
        вихід::вміст = гілка_тексту;
        вихід_позиції_кінця::вміст = п;
        вернути так;
      } інакше якщо слова.дані[п].вид == ВидСловаБагаторядковийТекст {
        змінна ціль гілка_тексту = виділити<Гілка>();
        гілка_тексту.вид = ВидГілкиТекст;
        гілка_тексту.дані = ДаніГілкиТекст {
          ідентифікатор = можливо<Ідентифікатор> { позитивне(так), Ідентифікатор { позиція_ідентифікатора } },
          позиція_слова = п
        };
        гілка_тексту.місцезнаходження = Місцезнаходження { позиція_ідентифікатора };
        вихід::вміст = гілка_тексту;
        вихід_позиції_кінця::вміст = п;
        вернути так;
      } інакше якщо слова.дані[п].вид == ВидСловаСимвол {
        змінна ціль гілка_символа = виділити<Гілка>();
        гілка_символа.вид = ВидГілкиСимвол;
        гілка_символа.дані = ДаніГілкиСимвол {
          ідентифікатор = можливо<Ідентифікатор> { позитивне(так), Ідентифікатор { позиція_ідентифікатора } },
          позиція_слова = п
        };
        гілка_символа.місцезнаходження = Місцезнаходження { позиція_ідентифікатора };
        вихід::вміст = гілка_символа;
        вихід_позиції_кінця::вміст = п;
        вернути так;
      } інакше {
        п -= 1;
      }
      змінна ціль гілка_звернення = виділити<Гілка>();
      гілка_звернення.вид = ВидГілкиЗвернутись;
      гілка_звернення.дані = ДаніГілкиЗвернутись {
        ідентифікатор = Ідентифікатор { п }
      };
      гілка_звернення.місцезнаходження = Місцезнаходження { п };
      вихід::вміст = гілка_звернення;
      вихід_позиції_кінця::вміст = п;
      вернути так;
    }
    якщо слова.дані[п].вид == ВидСловаЧисло {
      змінна ціль гілка_звернення = виділити<Гілка>();
      гілка_звернення.вид = ВидГілкиЧисло;
      гілка_звернення.дані = ДаніГілкиЧисло {
        позиція_слова = п
      };
      гілка_звернення.місцезнаходження = Місцезнаходження { п };
      вихід::вміст = гілка_звернення;
      вихід_позиції_кінця::вміст = п;
      вернути так;
    }
    якщо слова.дані[п].вид == ВидСловаДесятковеЧисло {
      змінна ціль гілка_звернення = виділити<Гілка>();
      гілка_звернення.вид = ВидГілкиЧисло;
      гілка_звернення.дані = ДаніГілкиЧисло {
        позиція_слова = п
      };
      гілка_звернення.місцезнаходження = Місцезнаходження { п };
      вихід::вміст = гілка_звернення;
      вихід_позиції_кінця::вміст = п;
      вернути так;
    }
    якщо слова.дані[п].вид == ВидСловаТекст {
      змінна ціль гілка_тексту = виділити<Гілка>();
      гілка_тексту.вид = ВидГілкиТекст;
      гілка_тексту.дані = ДаніГілкиТекст {
        ідентифікатор = можливо<Ідентифікатор> { позитивне(ні), ... },
        позиція_слова = п
      };
      гілка_тексту.місцезнаходження = Місцезнаходження { п };
      вихід::вміст = гілка_тексту;
      вихід_позиції_кінця::вміст = п;
      вернути так;
    }
    якщо слова.дані[п].вид == ВидСловаБагаторядковийТекст {
      змінна ціль гілка_тексту = виділити<Гілка>();
      гілка_тексту.вид = ВидГілкиТекст;
      гілка_тексту.дані = ДаніГілкиТекст {
        ідентифікатор = можливо<Ідентифікатор> { позитивне(ні), ... },
        позиція_слова = п
      };
      гілка_тексту.місцезнаходження = Місцезнаходження { п };
      вихід::вміст = гілка_тексту;
      вихід_позиції_кінця::вміст = п;
      вернути так;
    }
    якщо слова.дані[п].вид == ВидСловаСимвол {
      ціль гілка_символа = виділити<Гілка>();
      гілка_символа.вид = ВидГілкиСимвол;
      гілка_символа.дані = ДаніГілкиСимвол {
        ідентифікатор = можливо<Ідентифікатор> { позитивне(ні), ... },
        позиція_слова = п
      };
      гілка_символа.місцезнаходження = Місцезнаходження { п };
      вихід::вміст = гілка_символа;
      вихід_позиції_кінця::вміст = п;
      вернути так;
    }
    вернути ні;
  }

  дія спробувати_розібрати_атом(слова: Накопичувач<Слово>, позиція_початку: позитивне, вихід: адреса<адреса<Гілка>>, вихід_позиції_кінця: адреса<позитивне>): логічне {
    змінна ціль п = позиція_початку;
    якщо слова.дані[п].вид == ВидСловаСимволКвадратнаВідкритаДужка {
      ціль позиція_початку_списку = п;
      п += 1;
      якщо слова.дані[п].вид == ВидСловаСимволКвадратнаЗакритаДужка {
        ціль гілка_списку = виділити<Гілка>();
        гілка_списку.вид = ВидГілкиСписок;
        гілка_списку.дані = ДаніГілкиСписок {
          кількість_елементів = 0,
          елементи = пусто
        };
        гілка_списку.місцезнаходження = Місцезнаходження { позиція_початку_списку };
        вихід::вміст = гілка_списку;
        вихід_позиції_кінця::вміст = п;
        вернути так;
      }
      якщо слова.дані[п].вид == ВидСловаСимволРівно {
        п += 1;
        якщо слова.дані[п].вид == ВидСловаСимволКвадратнаЗакритаДужка {
          ціль гілка_словника = виділити<Гілка>();
          гілка_словника.вид = ВидГілкиСловник;
          гілка_словника.дані = ДаніГілкиСловник {
            кількість_елементів = 0,
            елементи = пусто
          };
          гілка_словника.місцезнаходження = Місцезнаходження { позиція_початку_списку };
          вихід::вміст = гілка_словника;
          вихід_позиції_кінця::вміст = п;
          вернути так;
        }
        вернути ні;
      }
      ціль елементи_списку = зробити_накопичувач<адреса<Гілка>>();
      ціль елементи_словника = зробити_накопичувач<ЕлементСловника>();
      поки п < слова.розмір {
        змінна ціль гілка_ключа_елемента: адреса<Гілка> = пусто;
        змінна ціль гілка_значення_елемента: адреса<Гілка> = пусто;
        якщо спробувати_розібрати_частинку(слова, п, гілка_ключа_елемента::адреса, п::адреса) {
          п += 1;
          якщо слова.дані[п].вид == ВидСловаСимволРівно {
            п += 1;
            якщо спробувати_розібрати_значення(слова, п, гілка_значення_елемента::адреса, п::адреса) {
              п += 1;
            } інакше {
              звільнити_гілку(гілка_ключа_елемента);
              // потім: пройтись по елементах і звільнити гілки
              звільнити_дані_накопичувача<адреса<Гілка>>(елементи_списку);
              звільнити_дані_накопичувача<ЕлементСловника>(елементи_словника);
              вернути ні;
            }
          } інакше {
            гілка_значення_елемента = гілка_ключа_елемента;
            гілка_ключа_елемента = пусто;
          }
        } інакше {
          якщо спробувати_розібрати_значення(слова, п, гілка_значення_елемента::адреса, п::адреса) {
            п += 1;
          } інакше {
            // потім: пройтись по елементах і звільнити гілки
            звільнити_дані_накопичувача<адреса<Гілка>>(елементи_списку);
            звільнити_дані_накопичувача<ЕлементСловника>(елементи_словника);
            вернути ні;
          }
        }
        якщо гілка_ключа_елемента == пусто {
          якщо елементи_словника.розмір != 0 {
            звільнити_гілку(гілка_ключа_елемента);
            звільнити_гілку(гілка_значення_елемента);
            // потім: пройтись по елементах і звільнити гілки
            звільнити_дані_накопичувача<адреса<Гілка>>(елементи_списку);
            звільнити_дані_накопичувача<ЕлементСловника>(елементи_словника);
            вернути ні;
          }
          покласти_в_накопичувач<адреса<Гілка>>(елементи_списку::адреса, гілка_значення_елемента);
        } інакше {
          якщо елементи_списку.розмір != 0 {
            звільнити_гілку(гілка_ключа_елемента);
            звільнити_гілку(гілка_значення_елемента);
            // потім: пройтись по елементах і звільнити гілки
            звільнити_дані_накопичувача<адреса<Гілка>>(елементи_списку);
            звільнити_дані_накопичувача<ЕлементСловника>(елементи_словника);
            вернути ні;
          }
          покласти_в_накопичувач<ЕлементСловника>(елементи_словника::адреса, ЕлементСловника {
            ключ = гілка_ключа_елемента,
            значення = гілка_значення_елемента,
            місцезнаходження = Місцезнаходження { позиція_початку }
          });
        }
        якщо слова.дані[п].вид == ВидСловаСимволКома {
          п += 1;
        } інакше якщо слова.дані[п].вид == ВидСловаСимволКвадратнаЗакритаДужка {
          якщо елементи_словника.розмір != 0 {
            ціль гілка_словника = виділити<Гілка>();
            гілка_словника.вид = ВидГілкиСловник;
            гілка_словника.дані = ДаніГілкиСловник {
              кількість_елементів = елементи_словника.розмір,
              елементи = елементи_словника.дані
            };
            гілка_словника.місцезнаходження = Місцезнаходження { позиція_початку_списку };
            вихід::вміст = гілка_словника;
            вихід_позиції_кінця::вміст = п;
            вернути так;
          } інакше {
            ціль гілка_списку = виділити<Гілка>();
            гілка_списку.вид = ВидГілкиСписок;
            гілка_списку.дані = ДаніГілкиСписок {
              кількість_елементів = елементи_списку.розмір,
              елементи = елементи_списку.дані
            };
            гілка_списку.місцезнаходження = Місцезнаходження { позиція_початку_списку };
            вихід::вміст = гілка_списку;
            вихід_позиції_кінця::вміст = п;
            вернути так;
          }
        } інакше {
          // потім: пройтись по елементах і звільнити гілки
          звільнити_дані_накопичувача<адреса<Гілка>>(елементи_списку);
          звільнити_дані_накопичувача<ЕлементСловника>(елементи_словника);
        }
      }
      // потім: пройтись по елементах і звільнити гілки
      звільнити_дані_накопичувача<адреса<Гілка>>(елементи_списку);
      звільнити_дані_накопичувача<ЕлементСловника>(елементи_словника);
      вернути ні;
    }
    п = позиція_початку;
    якщо спробувати_розібрати_частинку(слова, п, вихід, вихід_позиції_кінця) {
      вернути так;
    }
    вернути ні;
  }

  дія спробувати_розібрати_аргумент(слова: Накопичувач<Слово>, позиція_початку: позитивне, вихід: адреса<Аргумент>, вихід_позиції_кінця: адреса<позитивне>): логічне {
    змінна ціль п = позиція_початку;
    змінна ціль має_ідентифікатор = ні;
    ціль позиція_ідентифікатора = п;
    якщо слова.дані[п].вид == ВидСловаІдентифікатор {
      має_ідентифікатор = так;
      п += 1;
      якщо слова.дані[п].вид == ВидСловаСимволРівно {
        п += 1;
      } інакше {
        має_ідентифікатор = ні;
        п -= 1;
      }
    }
    змінна ціль гілка_значення_аргумента: адреса<Гілка> = пусто;
    якщо спробувати_розібрати_значення(слова, п, гілка_значення_аргумента::адреса, п::адреса) {
      якщо має_ідентифікатор {
        вихід::вміст = Аргумент {
          ідентифікатор = можливо<Ідентифікатор> { позитивне(так), Ідентифікатор { позиція_ідентифікатора } },
          значення = гілка_значення_аргумента,
          місцезнаходження = Місцезнаходження { позиція_початку }
        };
      } інакше {
        вихід::вміст = Аргумент {
          ідентифікатор = можливо<Ідентифікатор> { позитивне(ні), ... },
          значення = гілка_значення_аргумента,
          місцезнаходження = Місцезнаходження { позиція_початку }
        };
      }
      вихід_позиції_кінця::вміст = п;
      вернути так;
    }
    вернути ні;
  }

  //
  // --- з рекурсією ---
  // молекула = (молекула ('.' ідентифікатор)) | атом;
  //
  // --- без рекурсії ---
  // молекула = атом хвіст_молекули;
  // хвіст_молекули = ('.' ідентифікатор хвіст_молекули) | ;
  //
  дія спробувати_розібрати_молекулу(слова: Накопичувач<Слово>, позиція_початку: позитивне, вихід: адреса<адреса<Гілка>>, вихід_позиції_кінця: адреса<позитивне>): логічне {
    змінна ціль п: позитивне = позиція_початку;
    змінна ціль гілка_атома: адреса<Гілка> = пусто;
    якщо спробувати_розібрати_атом(слова, п, гілка_атома::адреса, п::адреса) {
      п += 1;
      змінна ціль гілка_хвоста: адреса<Гілка> = пусто;
      якщо спробувати_розібрати_молекулу__хвіст(слова, п, гілка_хвоста::адреса, п::адреса, гілка_атома) {
        вихід::вміст = гілка_хвоста;
        вихід_позиції_кінця::вміст = п;
        вернути так;
      } інакше {
        п -= 1;
      }
      вихід::вміст = гілка_атома;
      вихід_позиції_кінця::вміст = п;
      вернути так;
    } інакше {
      стрибнути звільнити_і_вийти;
    }
    звільнити_і_вийти:
    вернути ні;
  }

  дія спробувати_розібрати_молекулу__хвіст(слова: Накопичувач<Слово>, позиція_початку: позитивне, вихід: адреса<адреса<Гілка>>, вихід_позиції_кінця: адреса<позитивне>, гілка_атома: адреса<Гілка>): логічне {
    змінна ціль п = позиція_початку;
    якщо слова.дані[п].вид == ВидСловаСимволКрапка { // отримати властивість
      п += 1;
      якщо слова.дані[п].вид == ВидСловаІдентифікатор {
        ціль гілка_отримати_властивість = виділити<Гілка>();
        гілка_отримати_властивість.вид = ВидГілкиОтримати;
        гілка_отримати_властивість.дані = ДаніГілкиОтримати {
          предмет = гілка_атома,
          ідентифікатор = Ідентифікатор { п }
        };
        гілка_отримати_властивість.місцезнаходження = Місцезнаходження { 0 };
        п += 1;
        якщо спробувати_розібрати_молекулу__хвіст(слова, п, вихід, вихід_позиції_кінця, гілка_отримати_властивість) {
          вернути так;
        } інакше {
          звільнити_гілку(гілка_отримати_властивість);
          вернути ні;
        }
      }
      вернути ні;
    } інакше якщо слова.дані[п].вид == ВидСловаСимволКвадратнаВідкритаДужка { // отримати елемент
      п += 1;
      змінна ціль гілка_ключа: адреса<Гілка> = пусто;
      якщо спробувати_розібрати_молекулу(слова, п, гілка_ключа::адреса, п::адреса) {
        п += 1;
      } інакше {
        вернути ні;
      }
      ціль гілка_отримати_елемент = виділити<Гілка>();
      гілка_отримати_елемент.вид = ВидГілкиОтриматиЕлемент;
      гілка_отримати_елемент.дані = ДаніГілкиОтриматиЕлемент {
        предмет = гілка_атома,
        ключ = гілка_ключа
      };
      гілка_отримати_елемент.місцезнаходження = Місцезнаходження { 0 };
      якщо слова.дані[п].вид == ВидСловаСимволКвадратнаЗакритаДужка {
        п += 1;
        якщо спробувати_розібрати_молекулу__хвіст(слова, п, вихід, вихід_позиції_кінця, гілка_отримати_елемент) {
          вернути так;
        }
      }
      звільнити_гілку(гілка_отримати_елемент);
      вернути ні;
    } інакше якщо слова.дані[п].вид == ВидСловаСимволВідкритаДужка { // виконати дію
      п += 1;
      ціль аргументи = зробити_накопичувач<Аргумент>();
      якщо слова.дані[п].вид == ВидСловаСимволЗакритаДужка {
        п += 1;
        стрибнути виклик__хвіст;
      }
      поки п < слова.розмір {
        змінна ціль аргумент = Аргумент { ... };
        якщо спробувати_розібрати_аргумент(слова, п, аргумент::адреса, п::адреса) {
          покласти_в_накопичувач<Аргумент>(аргументи::адреса, аргумент);
          п += 1;
          якщо слова.дані[п].вид == ВидСловаСимволЗакритаДужка {
            п += 1;
            стрибнути виклик__хвіст;
          } інакше якщо слова.дані[п].вид == ВидСловаСимволКома {
            п += 1;
          } інакше {
            // потім: звільнити кожен аргумент
            звільнити_дані_накопичувача<Аргумент>(аргументи);
            вернути ні;
          }
        } інакше {
            // потім: звільнити кожен аргумент
          звільнити_дані_накопичувача<Аргумент>(аргументи);
          вернути ні;
        }
      }
      якщо слова.дані[п].вид == ВидСловаСимволЗакритаДужка {
        п += 1;
        виклик__хвіст:
        ціль гілка_виконати = виділити<Гілка>();
        гілка_виконати.вид = ВидГілкиВиконати;
        гілка_виконати.дані = ДаніГілкиВиконати {
          предмет = гілка_атома,
          кількість_аргументів = аргументи.розмір,
          аргументи = аргументи.дані,
        };
        гілка_виконати.місцезнаходження = Місцезнаходження { 0 };
        якщо спробувати_розібрати_молекулу__хвіст(слова, п, вихід, вихід_позиції_кінця, гілка_виконати) {
          вернути так;
        }
      }
      // потім: звільнити кожен аргумент
      звільнити_дані_накопичувача<Аргумент>(аргументи);
      вернути ні;
    }
    вихід::вміст = гілка_атома;
    вихід_позиції_кінця::вміст = п - 1;
    вернути так;
  }

  дія спробувати_розібрати_значення(слова: Накопичувач<Слово>, позиція_початку: позитивне, вихід: адреса<адреса<Гілка>>, вихід_позиції_кінця: адреса<позитивне>): логічне {
    якщо спробувати_розібрати_дію(слова, позиція_початку, вихід, вихід_позиції_кінця) {
      вернути так;
    }
    якщо спробувати_розібрати_структуру(слова, позиція_початку, вихід, вихід_позиції_кінця) {
      вернути так;
    }
    якщо спробувати_розібрати_модуль(слова, позиція_початку, вихід, вихід_позиції_кінця) {
      вернути так;
    }
    якщо спробувати_розібрати_молекулу(слова, позиція_початку, вихід, вихід_позиції_кінця) {
      вернути так;
    }
    вернути ні;
  }

  дія спробувати_розібрати_визначити(слова: Накопичувач<Слово>, позиція_початку: позитивне, вихід: адреса<адреса<Гілка>>, вихід_позиції_кінця: адреса<позитивне>): логічне {
    змінна ціль п = позиція_початку;
    ціль позиція_ідентифікатора = п;
    якщо слова.дані[п].вид != ВидСловаІдентифікатор {
      вернути ні;
    }
    п += 1;
    якщо слова.дані[п].вид != ВидСловаСимволРівно {
      якщо слова.дані[п].вид != ВидСловаЦе {
        вернути ні;
      }
    }
    п += 1;
    змінна ціль гілка_значення: адреса<Гілка> = пусто;
    якщо спробувати_розібрати_значення(слова, п, гілка_значення::адреса, п::адреса) {
      ціль гілка_визначити = виділити<Гілка>();
      гілка_визначити.вид = ВидГілкиВизначити;
      гілка_визначити.дані = ДаніГілкиВизначити {
        ідентифікатор = Ідентифікатор { позиція_ідентифікатора },
        значення = гілка_значення
      };
      гілка_визначити.місцезнаходження = Місцезнаходження { позиція_початку };
      вихід::вміст = гілка_визначити;
      вихід_позиції_кінця::вміст = п;
      вернути так;
    }
    вернути ні;
  }

  дія спробувати_розібрати_вернути(слова: Накопичувач<Слово>, позиція_початку: позитивне, вихід: адреса<адреса<Гілка>>, вихід_позиції_кінця: адреса<позитивне>): логічне {
    змінна ціль п: позитивне = позиція_початку;
    якщо слова.дані[п].вид != ВидСловаВернути {
      вернути ні;
    }
    п += 1;
    змінна ціль гілка_значення: адреса<Гілка> = пусто;
    якщо спробувати_розібрати_значення(слова, п, гілка_значення::адреса, п::адреса) {
    } інакше {
      п -= 1;
    }
    ціль гілка_вернути = виділити<Гілка>();
    гілка_вернути.вид = ВидГілкиВернути;
    гілка_вернути.дані = ДаніГілкиВернути {
      значення = гілка_значення
    };
    гілка_вернути.місцезнаходження = Місцезнаходження { позиція_початку };
    вихід::вміст = гілка_вернути;
    вихід_позиції_кінця::вміст = п;
    вернути так;
  }

  дія спробувати_розібрати_впасти(слова: Накопичувач<Слово>, позиція_початку: позитивне, вихід: адреса<адреса<Гілка>>, вихід_позиції_кінця: адреса<позитивне>): логічне {
    змінна ціль п: позитивне = позиція_початку;
    якщо слова.дані[п].вид != ВидСловаВпасти {
      вернути ні;
    }
    п += 1;
    змінна ціль гілка_значення: адреса<Гілка> = пусто;
    якщо спробувати_розібрати_значення(слова, п, гілка_значення::адреса, п::адреса) {
    } інакше {
      п -= 1;
    }
    ціль гілка_впасти = виділити<Гілка>();
    гілка_впасти.вид = ВидГілкиВпасти;
    гілка_впасти.дані = ДаніГілкиВпасти {
      значення = гілка_значення
    };
    гілка_впасти.місцезнаходження = Місцезнаходження { позиція_початку };
    вихід::вміст = гілка_впасти;
    вихід_позиції_кінця::вміст = п;
    вернути так;
  }

  дія спробувати_розібрати_елемент_взяти(слова: Накопичувач<Слово>, позиція_початку: позитивне, вихід: адреса<ЕлементВзяти>, вихід_позиції_кінця: адреса<позитивне>): логічне {
    змінна ціль п: позитивне = позиція_початку;
    ціль позиція_ідентифікатора = п;
    якщо слова.дані[п].вид != ВидСловаІдентифікатор {
      вернути ні;
    }
    п += 1;
    змінна ціль має_ідентифікатор_як = ні;
    змінна ціль позиція_ідентифікатора_як = п + 1;
    якщо слова.дані[п].вид == ВидСловаЯк {
      п += 1;
      якщо слова.дані[п].вид != ВидСловаІдентифікатор {
        вернути ні;
      }
      має_ідентифікатор_як = так;
      позиція_ідентифікатора_як = п;
    } інакше {
      п -= 1;
    }
    вихід::вміст = ЕлементВзяти {
      ідентифікатор = Ідентифікатор { позиція_ідентифікатора },
      ідентифікатор_як = можливо<Ідентифікатор> { позитивне(має_ідентифікатор_як), Ідентифікатор { позиція_ідентифікатора_як } },
      місцезнаходження = Місцезнаходження { позиція_початку }
    };
    вихід_позиції_кінця::вміст = п;
    вернути так;
  }

  дія спробувати_розібрати_взяти(слова: Накопичувач<Слово>, позиція_початку: позитивне, вихід: адреса<адреса<Гілка>>, вихід_позиції_кінця: адреса<позитивне>): логічне {
    змінна ціль п: позитивне = позиція_початку;
    ціль шлях = зробити_накопичувач<Ідентифікатор>();
    якщо слова.дані[п].вид != ВидСловаВзяти {
      звільнити_дані_накопичувача<Ідентифікатор>(шлях);
      вернути ні;
    }
    п += 1;
    ціль позиція_виду_взяти = п;
    якщо слова.дані[п].вид == ВидСловаМодуль {
      п += 1;
    } інакше якщо слова.дані[п].вид == ВидСловаІдентифікатор {
      п += 1;
    } інакше {
      звільнити_дані_накопичувача<Ідентифікатор>(шлях);
      вернути ні;
    }
    поки п < слова.розмір {
      якщо слова.дані[п].вид == ВидСловаІдентифікатор {
        покласти_в_накопичувач<Ідентифікатор>(шлях::адреса, Ідентифікатор { п });
        п += 1;
        якщо слова.дані[п].вид == ВидСловаСимволКрапка {
          п += 1;
        } інакше {
          стрибнути після_шляху;
        }
      } інакше {
        звільнити_дані_накопичувача<Ідентифікатор>(шлях);
        вернути ні;
      }
    }
    після_шляху:
    якщо слова.дані[п].вид == ВидСловаЯк {
      п += 1;
      ціль ідентифікатор_як = п;
      якщо слова.дані[п].вид != ВидСловаІдентифікатор {
        звільнити_дані_накопичувача<Ідентифікатор>(шлях);
        вернути ні;
      }
      ціль гілка_взяти = виділити<Гілка>();
      гілка_взяти.вид = ВидГілкиВзяти;
      гілка_взяти.дані = ДаніГілкиВзяти {
        тип = можливо<Ідентифікатор> { позитивне(так), Ідентифікатор { позиція_виду_взяти } },
        довжина_шляху = шлях.розмір,
        шлях = шлях.дані,
        ідентифікатор_як = можливо<Ідентифікатор> { позитивне(так), Ідентифікатор { ідентифікатор_як } },
        кількість_елементів = 0,
        елементи = пусто
      };
      гілка_взяти.місцезнаходження = Місцезнаходження { позиція_початку };
      вихід::вміст = гілка_взяти;
      вихід_позиції_кінця::вміст = п;
      вернути так;
    } інакше якщо слова.дані[п].вид == ВидСловаСимволКвадратнаВідкритаДужка {
      п += 1;
      ціль елементи = зробити_накопичувач<ЕлементВзяти>();
      поки п < слова.розмір {
        змінна ціль елемент_взяти = ЕлементВзяти { ... };
        якщо спробувати_розібрати_елемент_взяти(слова, п, елемент_взяти::адреса, п::адреса) {
          покласти_в_накопичувач<ЕлементВзяти>(елементи::адреса, елемент_взяти);
          п += 1;
          якщо слова.дані[п].вид == ВидСловаСимволКома {
            п += 1;
          } інакше якщо слова.дані[п].вид == ВидСловаСимволКвадратнаЗакритаДужка {
            ціль гілка_взяти = виділити<Гілка>();
            гілка_взяти.вид = ВидГілкиВзяти;
            гілка_взяти.дані = ДаніГілкиВзяти {
              тип = можливо<Ідентифікатор> { позитивне(так), Ідентифікатор { позиція_виду_взяти } },
              довжина_шляху = шлях.розмір,
              шлях = шлях.дані,
              ідентифікатор_як = можливо<Ідентифікатор> { позитивне(ні), ... },
              кількість_елементів = елементи.розмір,
              елементи = елементи.дані
            };
            гілка_взяти.місцезнаходження = Місцезнаходження { позиція_початку };
            вихід::вміст = гілка_взяти;
            вихід_позиції_кінця::вміст = п;
            вернути так;
          } інакше {
            звільнити_дані_накопичувача<Ідентифікатор>(шлях);
            звільнити_дані_накопичувача<ЕлементВзяти>(елементи);
            вернути ні;
          }
        } інакше {
          звільнити_дані_накопичувача<Ідентифікатор>(шлях);
          звільнити_дані_накопичувача<ЕлементВзяти>(елементи);
          вернути ні;
        }
      }
      звільнити_дані_накопичувача<Ідентифікатор>(шлях);
      звільнити_дані_накопичувача<ЕлементВзяти>(елементи);
      вернути ні;
    } інакше {
      ціль гілка_взяти = виділити<Гілка>();
      гілка_взяти.вид = ВидГілкиВзяти;
      гілка_взяти.дані = ДаніГілкиВзяти {
        тип = можливо<Ідентифікатор> { позитивне(так), Ідентифікатор { позиція_виду_взяти } },
        довжина_шляху = шлях.розмір,
        шлях = шлях.дані,
        ідентифікатор_як = можливо<Ідентифікатор> { позитивне(ні), ... },
        кількість_елементів = 0,
        елементи = пусто
      };
      гілка_взяти.місцезнаходження = Місцезнаходження { позиція_початку };
      вихід::вміст = гілка_взяти;
      вихід_позиції_кінця::вміст = п - 1;
      вернути так;
    }
    звільнити_дані_накопичувача<Ідентифікатор>(шлях);
    вернути ні;
  }

  дія спробувати_розібрати_елемент_дати(слова: Накопичувач<Слово>, позиція_початку: позитивне, вихід: адреса<ЕлементДати>, вихід_позиції_кінця: адреса<позитивне>): логічне {
    змінна ціль п = позиція_початку;
    ціль позиція_ідентифікатора = п;
    якщо слова.дані[п].вид != ВидСловаІдентифікатор {
      вернути ні;
    }
    п += 1;
    змінна ціль має_ідентифікатор_як = ні;
    змінна ціль позиція_ідентифікатора_як = п + 1;
    якщо слова.дані[п].вид == ВидСловаЯк {
      п += 1;
      якщо слова.дані[п].вид != ВидСловаІдентифікатор {
        вернути ні;
      }
      має_ідентифікатор_як = так;
      позиція_ідентифікатора_як = п;
    } інакше {
      п -= 1;
    }
    вихід::вміст = ЕлементДати {
      ідентифікатор = Ідентифікатор { позиція_ідентифікатора },
      ідентифікатор_як = можливо<Ідентифікатор> { позитивне(має_ідентифікатор_як), Ідентифікатор { позиція_ідентифікатора_як } },
      місцезнаходження = Місцезнаходження { позиція_початку }
    };
    вихід_позиції_кінця::вміст = п;
    вернути так;
  }

  дія спробувати_розібрати_дати(слова: Накопичувач<Слово>, позиція_початку: позитивне, вихід: адреса<адреса<Гілка>>, вихід_позиції_кінця: адреса<позитивне>): логічне {
    змінна ціль п: позитивне = позиція_початку;
    якщо слова.дані[п].вид != ВидСловаДати {
      вернути ні;
    }
    п += 1;
    ціль елементи = зробити_накопичувач<ЕлементДати>();
    поки п < слова.розмір {
      змінна ціль елемент_дати = ЕлементДати { ... };
      якщо спробувати_розібрати_елемент_дати(слова, п, елемент_дати::адреса, п::адреса) {
        покласти_в_накопичувач<ЕлементДати>(елементи::адреса, елемент_дати);
        п += 1;
        якщо слова.дані[п].вид == ВидСловаСимволКома {
          п += 1;
        } інакше {
          п -= 1;
          стрибнути завершення;
        }
      } інакше {
        звільнити_дані_накопичувача<ЕлементДати>(елементи);
        вернути ні;
      }
    }
    завершення:
    ціль гілка_дати = виділити<Гілка>();
    гілка_дати.вид = ВидГілкиДати;
    гілка_дати.дані = ДаніГілкиДати {
      кількість_елементів = елементи.розмір,
      елементи = елементи.дані
    };
    гілка_дати.місцезнаходження = Місцезнаходження { позиція_початку };
    вихід::вміст = гілка_дати;
    вихід_позиції_кінця::вміст = п;
    вернути так;
  }

  дія спробувати_розібрати_елемент_тіла(слова: Накопичувач<Слово>, позиція_початку: позитивне, вихід: адреса<адреса<Гілка>>, вихід_позиції_кінця: адреса<позитивне>): логічне {
    якщо спробувати_розібрати_вернути(слова, позиція_початку, вихід, вихід_позиції_кінця) {
      вернути так;
    }
    якщо спробувати_розібрати_впасти(слова, позиція_початку, вихід, вихід_позиції_кінця) {
      вернути так;
    }
    якщо спробувати_розібрати_взяти(слова, позиція_початку, вихід, вихід_позиції_кінця) {
      вернути так;
    }
    якщо спробувати_розібрати_дати(слова, позиція_початку, вихід, вихід_позиції_кінця) {
      вернути так;
    }
    якщо спробувати_розібрати_якщо(слова, позиція_початку, вихід, вихід_позиції_кінця) {
      вернути так;
    }
    якщо спробувати_розібрати_поки(слова, позиція_початку, вихід, вихід_позиції_кінця) {
      вернути так;
    }
    якщо спробувати_розібрати_цикл(слова, позиція_початку, вихід, вихід_позиції_кінця) {
      вернути так;
    }
    якщо спробувати_розібрати_перебрати(слова, позиція_початку, вихід, вихід_позиції_кінця) {
      вернути так;
    }
    якщо спробувати_розібрати_спробувати(слова, позиція_початку, вихід, вихід_позиції_кінця) {
      вернути так;
    }
    якщо спробувати_розібрати_визначити(слова, позиція_початку, вихід, вихід_позиції_кінця) {
      вернути так;
    }
    якщо спробувати_розібрати_значення(слова, позиція_початку, вихід, вихід_позиції_кінця) {
      вернути так;
    }
    вернути ні;
  }

  дія спробувати_розібрати_тіло(слова: Накопичувач<Слово>, позиція_початку: позитивне, вихід: адреса<СписокГілок>, вихід_позиції_кінця: адреса<позитивне>, вид_слова_закінчення: позитивне): логічне {
    змінна ціль п: позитивне = позиція_початку;
    змінна ціль елементи = зробити_накопичувач<адреса<Гілка>>();
    поки п < слова.розмір {
      якщо слова.дані[п].вид == вид_слова_закінчення {
        вихід::вміст = СписокГілок { елементи.розмір, елементи.дані };
        вихід_позиції_кінця::вміст = п;
        вернути так;
      }
      змінна ціль гілка_елемента_тіла: адреса<Гілка> = пусто;
      якщо спробувати_розібрати_елемент_тіла(слова, п, гілка_елемента_тіла::адреса, п::адреса) {
        покласти_в_накопичувач<адреса<Гілка>>(елементи::адреса, гілка_елемента_тіла);
        п += 1;
        якщо слова.дані[п].вид == ВидСловаСимволМіжряд {
          п += 1;
        } інакше якщо слова.дані[п].вид == вид_слова_закінчення {
          вихід::вміст = СписокГілок { елементи.розмір, елементи.дані };
          вихід_позиції_кінця::вміст = п;
          вернути так;
        } інакше {
          // потім: пройтись по елементам і звільнити кожну гілку
          звільнити_дані_накопичувача<адреса<Гілка>>(елементи);
          вернути ні;
        }
      } інакше {
        // потім: пройтись по елементам і звільнити кожну гілку
        звільнити_дані_накопичувача<адреса<Гілка>>(елементи);
        вернути ні;
      }
    }
    // потім: пройтись по елементам і звільнити кожну гілку
    звільнити_дані_накопичувача<адреса<Гілка>>(елементи);
    вернути ні;
  }

  дія спробувати_розібрати_тип(слова: Накопичувач<Слово>, позиція_початку: позитивне, вихід: адреса<Тип>, вихід_позиції_кінця: адреса<позитивне>): логічне {
    змінна ціль п = позиція_початку;
    змінна ціль типи = зробити_накопичувач<адреса<Гілка>>();
    поки п < слова.розмір {
      змінна ціль гілка_типу: адреса<Гілка> = пусто;
      якщо спробувати_розібрати_молекулу(слова, п, гілка_типу::адреса, п::адреса) {
        покласти_в_накопичувач<адреса<Гілка>>(типи::адреса, гілка_типу);
        п += 1;
        якщо слова.дані[п].вид == ВидСловаАбо {
          п += 1;
        } інакше {
          вихід::вміст = Тип {
            кількість_гілок = типи.розмір,
            гілки = типи.дані,
          };
          вихід_позиції_кінця::вміст = п - 1;
          вернути так;
        }
      } інакше {
        // потім: пройтись по всім гілкам типів і звільнити кожну
        звільнити_дані_накопичувача<адреса<Гілка>>(типи);
        вернути ні;
      }
    }
    // потім: пройтись по всім гілкам типів і звільнити кожну
    звільнити_дані_накопичувача<адреса<Гілка>>(типи);
    вернути ні;
  }

  дія спробувати_розібрати_параметр(слова: Накопичувач<Слово>, позиція_початку: позитивне, вихід: адреса<Параметр>, вихід_позиції_кінця: адреса<позитивне>): логічне {
    змінна ціль п: позитивне = позиція_початку;
    змінна ціль гілка_значення: адреса<Гілка> = пусто;
    // ідентифікатор параметра
    ціль позиція_ідентифікатора = п;
    якщо слова.дані[п].вид != ВидСловаІдентифікатор {
      вернути ні;
    }
    п += 1;
    // тип параметра
    змінна ціль тип: Тип;
    якщо спробувати_розібрати_тип(слова, п, тип::адреса, п::адреса) {
      п += 1;
      якщо слова.дані[п].вид == ВидСловаСимволРівно {
        п += 1;
        якщо спробувати_розібрати_значення(слова, п, гілка_значення::адреса, п::адреса) {
        } інакше {
          // потім: звільнити тип
          вернути ні;
        }
      } інакше {
        п -= 1;
      }
      вихід::вміст = Параметр {
        ідентифікатор = Ідентифікатор { позиція_ідентифікатора },
        тип = можливо<Тип> { позитивне(так), тип },
        значення = гілка_значення,
        місцезнаходження = Місцезнаходження { позиція_початку }
      };
      вихід_позиції_кінця::вміст = п;
    } інакше {
      якщо слова.дані[п].вид == ВидСловаСимволРівно {
        п += 1;
        якщо спробувати_розібрати_значення(слова, п, гілка_значення::адреса, п::адреса) {
        } інакше {
          вернути ні;
        }
      } інакше {
        п -= 1;
      }
      вихід::вміст = Параметр {
        ідентифікатор = Ідентифікатор { позиція_ідентифікатора },
        тип = можливо<Тип> { позитивне(ні), ... },
        значення = гілка_значення,
        місцезнаходження = Місцезнаходження { позиція_початку }
      };
      вихід_позиції_кінця::вміст = п;
    }
    вернути так;
  }

  дія спробувати_розібрати_дію(слова: Накопичувач<Слово>, позиція_початку: позитивне, вихід: адреса<адреса<Гілка>>, вихід_позиції_кінця: адреса<позитивне>): логічне {
    ціль дані_гілки_дія = ДаніГілкиДія {
      тривала = позитивне(ні),
      модифікатор = позитивне(0),
      структура_ = пусто,
      ідентифікатор = можливо<Ідентифікатор> { позитивне(ні), ... },
      кількість_параметрів = 0,
      параметри = пусто,
      тип_результату = можливо<Тип> { позитивне(ні), ... },
      тіло = СписокГілок { 0, пусто }
    };
    змінна ціль п: позитивне = позиція_початку;
    // дія власна?
    якщо слова.дані[п].вид == ВидСловаВласна {
      п += 1;
    }
    // дія тривала?
    якщо слова.дані[п].вид == ВидСловаТривала {
      дані_гілки_дія.тривала = позитивне(так);
      п += 1;
    }
    // дія?
    якщо слова.дані[п].вид != ВидСловаДія {
      стрибнути звільнити_і_вийти;
    }
    п += 1;
    // структура та/або ідентифікатор дії
    якщо слова.дані[п].вид == ВидСловаІдентифікатор {
      дані_гілки_дія.ідентифікатор = можливо<Ідентифікатор> { позитивне(так), Ідентифікатор { п } };
      п += 1;
      якщо слова.дані[п].вид == ВидСловаСимволКрапка {
        п += 1;
        якщо слова.дані[п].вид == ВидСловаІдентифікатор {
          дані_гілки_дія.структура_ = пусто; // потім: зробити гілку звернення для структури
          дані_гілки_дія.ідентифікатор = можливо<Ідентифікатор> { позитивне(так), Ідентифікатор { п } };
          п += 1;
        } інакше {
          стрибнути звільнити_і_вийти;
        }
      }
    }
    якщо слова.дані[п].вид != ВидСловаСимволВідкритаДужка {
      стрибнути звільнити_і_вийти;
    }
    п += 1;
    // параметри дії
    ціль параметри = зробити_накопичувач<Параметр>();
    поки п < слова.розмір {
      якщо слова.дані[п].вид == ВидСловаСимволЗакритаДужка {
        п += 1;
        стрибнути після_параметрів;
      }
      змінна ціль параметр: Параметр;
      якщо спробувати_розібрати_параметр(слова, п, параметр::адреса, п::адреса) {
        покласти_в_накопичувач<Параметр>(параметри::адреса, параметр);
        п += 1;
      } інакше {
        стрибнути звільнити_і_вийти;
      }
      якщо слова.дані[п].вид == ВидСловаСимволКома {
        п += 1;
      } інакше якщо слова.дані[п].вид == ВидСловаСимволЗакритаДужка {
        п += 1;
        стрибнути після_параметрів;
      } інакше {
        // потім: пройтись по параметрах і звільнити гілки
        звільнити_дані_накопичувача<Параметр>(параметри);
        стрибнути звільнити_і_вийти;
      }
    }
    після_параметрів:
    дані_гілки_дія.кількість_параметрів = параметри.розмір;
    дані_гілки_дія.параметри = параметри.дані;
    // тип результату дії
    якщо слова.дані[п].вид != ВидСловаСимволМіжряд {
      якщо спробувати_розібрати_тип(слова, п, дані_гілки_дія.тип_результату.значення::адреса, п::адреса) {
        дані_гілки_дія.тип_результату.заповнено = позитивне(так);
        п += 1;
      } інакше {
        стрибнути звільнити_і_вийти;
      }
      якщо слова.дані[п].вид == ВидСловаСимволМіжряд {
      } інакше {
        стрибнути звільнити_і_вийти;
      }
    }
    п += 1;
    // тіло дії
    якщо спробувати_розібрати_тіло(слова, п, дані_гілки_дія.тіло::адреса, п::адреса, ВидСловаКінець) == ні {
      стрибнути звільнити_і_вийти;
    }
    ціль гілка_дія = виділити<Гілка>();
    гілка_дія.вид = ВидГілкиДія;
    гілка_дія.дані = дані_гілки_дія;
    гілка_дія.місцезнаходження = Місцезнаходження {
      позиція_початку
    };
    вихід::вміст = гілка_дія;
    вихід_позиції_кінця::вміст = п;
    вернути так;
    звільнити_і_вийти:
    звільнити_параметри(дані_гілки_дія.кількість_параметрів, дані_гілки_дія.параметри);
    якщо дані_гілки_дія.тип_результату.заповнено == позитивне(так) {
      звільнити_тип(дані_гілки_дія.тип_результату.значення);
    }
    звільнити_тіло(дані_гілки_дія.тіло);
    вернути ні;
  }

  дія спробувати_розібрати_структуру(слова: Накопичувач<Слово>, позиція_початку: позитивне, вихід: адреса<адреса<Гілка>>, вихід_позиції_кінця: адреса<позитивне>): логічне {
    ціль дані_гілки_структура = ДаніГілкиСтруктура {
      ідентифікатор = можливо<Ідентифікатор> { позитивне(ні), ... },
      предок = пусто,
      кількість_параметрів = 0,
      параметри = пусто
    };
    змінна ціль п = позиція_початку;
    // структура?
    якщо слова.дані[п].вид != ВидСловаСтруктура {
      стрибнути звільнити_і_вийти;
    }
    п += 1;
    // ідентифікатор структури
    якщо слова.дані[п].вид == ВидСловаІдентифікатор {
      дані_гілки_структура.ідентифікатор = можливо<Ідентифікатор> { позитивне(так), Ідентифікатор { п } };
      п += 1;
    }
    // предок структури
    якщо слова.дані[п].вид == ВидСловаЄ {
      п += 1;
      якщо спробувати_розібрати_молекулу(слова, п, дані_гілки_структура.предок::адреса, п::адреса) {
        п += 1;
      } інакше {
        стрибнути звільнити_і_вийти;
      }
    }
    якщо слова.дані[п].вид != ВидСловаСимволМіжряд {
      стрибнути звільнити_і_вийти;
    }
    п += 1;
    // параметри структури
    ціль параметри = зробити_накопичувач<Параметр>();
    поки п < слова.розмір {
      якщо слова.дані[п].вид == ВидСловаКінець {
        стрибнути після_параметрів;
      }
      змінна ціль параметр: Параметр;
      якщо спробувати_розібрати_параметр(слова, п, параметр::адреса, п::адреса) {
        покласти_в_накопичувач<Параметр>(параметри::адреса, параметр);
        п += 1;
      } інакше {
        стрибнути звільнити_і_вийти;
      }
      якщо слова.дані[п].вид == ВидСловаСимволМіжряд {
        п += 1;
      } інакше якщо слова.дані[п].вид == ВидСловаКінець {
        стрибнути після_параметрів;
      } інакше {
        // потім: пройтись по параметрах і звільнити гілки
        звільнити_дані_накопичувача<Параметр>(параметри);
        стрибнути звільнити_і_вийти;
      }
    }
    після_параметрів:
    дані_гілки_структура.кількість_параметрів = параметри.розмір;
    дані_гілки_структура.параметри = параметри.дані;
    ціль гілка_структура = виділити<Гілка>();
    гілка_структура.вид = ВидГілкиСтруктура;
    гілка_структура.дані = дані_гілки_структура;
    гілка_структура.місцезнаходження = Місцезнаходження {
      позиція_початку
    };
    вихід::вміст = гілка_структура;
    вихід_позиції_кінця::вміст = п;
    вернути так;
    звільнити_і_вийти:
    звільнити_гілку(дані_гілки_структура.предок);
    звільнити_параметри(дані_гілки_структура.кількість_параметрів, дані_гілки_структура.параметри);
    вернути ні;
  }

  дія спробувати_розібрати_модуль(слова: Накопичувач<Слово>, позиція_початку: позитивне, вихід: адреса<адреса<Гілка>>, вихід_позиції_кінця: адреса<позитивне>): логічне {
    ціль дані_гілки_модуль = ДаніГілкиМодуль {
      ідентифікатор = можливо<Ідентифікатор> { позитивне(ні), ... },
      тіло = СписокГілок { 0, пусто }
    };
    змінна ціль п: позитивне = позиція_початку;
    // модуль?
    якщо слова.дані[п].вид != ВидСловаМодуль {
      стрибнути звільнити_і_вийти;
    }
    п += 1;
    // ідентифікатор модуля
    якщо слова.дані[п].вид == ВидСловаІдентифікатор {
      дані_гілки_модуль.ідентифікатор = можливо<Ідентифікатор> { позитивне(так), Ідентифікатор { п } };
      п += 1;
    }
    якщо слова.дані[п].вид != ВидСловаСимволМіжряд {
      стрибнути звільнити_і_вийти;
    }
    п += 1;
    // тіло модуля
    якщо спробувати_розібрати_тіло(слова, п, дані_гілки_модуль.тіло::адреса, п::адреса, ВидСловаКінець) == ні {
      стрибнути звільнити_і_вийти;
    }
    ціль гілка_модуль = виділити<Гілка>();
    гілка_модуль.вид = ВидГілкиМодуль;
    гілка_модуль.дані = дані_гілки_модуль;
    гілка_модуль.місцезнаходження = Місцезнаходження {
      позиція_початку
    };
    вихід::вміст = гілка_модуль;
    вихід_позиції_кінця::вміст = п;
    вернути так;
    звільнити_і_вийти:
    звільнити_тіло(дані_гілки_модуль.тіло);
    вернути ні;
  }

  дія спробувати_розібрати_якщо(слова: Накопичувач<Слово>, позиція_початку: позитивне, вихід: адреса<адреса<Гілка>>, вихід_позиції_кінця: адреса<позитивне>): логічне {
    ціль дані_гілки_якщо = ДаніГілкиЯкщо {
      умова = пусто,
      тіло = СписокГілок { 0, пусто },
      тіло_інакше = СписокГілок { 0, пусто }
    };
    змінна ціль п: позитивне = позиція_початку;
    // якщо?
    якщо слова.дані[п].вид != ВидСловаЯкщо {
      стрибнути звільнити_і_вийти;
    }
    п += 1;
    // умова якщо
    якщо спробувати_розібрати_молекулу(слова, п, дані_гілки_якщо.умова::адреса, п::адреса) {
      п += 1;
    } інакше {
      стрибнути звільнити_і_вийти;
    }
    якщо слова.дані[п].вид != ВидСловаСимволМіжряд {
      стрибнути звільнити_і_вийти;
    }
    п += 1;
    // тіло якщо
    змінна ціль тіло = зробити_накопичувач<адреса<Гілка>>();
    поки п < слова.розмір {
      якщо слова.дані[п].вид == ВидСловаКінець {
        дані_гілки_якщо.тіло.довжина = тіло.розмір;
        дані_гілки_якщо.тіло.елементи = тіло.дані;
        стрибнути після_тіла;
      }
      якщо слова.дані[п].вид == ВидСловаІнакше {
        дані_гілки_якщо.тіло.довжина = тіло.розмір;
        дані_гілки_якщо.тіло.елементи = тіло.дані;
        стрибнути розбір_інакше;
      }
      змінна ціль гілка_елемента_тіла: адреса<Гілка> = пусто;
      якщо спробувати_розібрати_елемент_тіла(слова, п, гілка_елемента_тіла::адреса, п::адреса) {
        покласти_в_накопичувач<адреса<Гілка>>(тіло::адреса, гілка_елемента_тіла);
        п += 1;
        якщо слова.дані[п].вид == ВидСловаСимволМіжряд {
          п += 1;
        } інакше якщо слова.дані[п].вид == ВидСловаКінець {
          дані_гілки_якщо.тіло.довжина = тіло.розмір;
          дані_гілки_якщо.тіло.елементи = тіло.дані;
          стрибнути після_тіла;
        } інакше якщо слова.дані[п].вид == ВидСловаІнакше {
          дані_гілки_якщо.тіло.довжина = тіло.розмір;
          дані_гілки_якщо.тіло.елементи = тіло.дані;
          стрибнути розбір_інакше;
        } інакше {
          дані_гілки_якщо.тіло.довжина = тіло.розмір;
          дані_гілки_якщо.тіло.елементи = тіло.дані;
          стрибнути звільнити_і_вийти;
        }
      } інакше {
        дані_гілки_якщо.тіло.довжина = тіло.розмір;
        дані_гілки_якщо.тіло.елементи = тіло.дані;
        стрибнути звільнити_і_вийти;
      }
    }
    стрибнути звільнити_і_вийти;
    розбір_інакше:
    п += 1;
    // інакше якщо
    якщо слова.дані[п].вид == ВидСловаЯкщо {
      змінна ціль гілка_інакше_якщо: адреса<Гілка> = пусто;
      якщо спробувати_розібрати_якщо(слова, п, гілка_інакше_якщо::адреса, п::адреса) {
        ціль накопичувач_інакше_якщо = зробити_накопичувач<адреса<Гілка>>();
        покласти_в_накопичувач<адреса<Гілка>>(накопичувач_інакше_якщо::адреса, гілка_інакше_якщо);
        дані_гілки_якщо.тіло_інакше = СписокГілок {
          накопичувач_інакше_якщо.розмір,
          накопичувач_інакше_якщо.дані
        };
        стрибнути після_тіла;
      }
      стрибнути звільнити_і_вийти;
    } інакше якщо слова.дані[п].вид == ВидСловаСимволМіжряд {
      п += 1;
      // тіло інакше
      якщо спробувати_розібрати_тіло(слова, п, дані_гілки_якщо.тіло_інакше::адреса, п::адреса, ВидСловаКінець) == ні {
        стрибнути звільнити_і_вийти;
      }
      стрибнути після_тіла;
    } інакше {
      стрибнути звільнити_і_вийти;
    }
    після_тіла:
    ціль гілка_якщо = виділити<Гілка>();
    гілка_якщо.вид = ВидГілкиЯкщо;
    гілка_якщо.дані = дані_гілки_якщо;
    гілка_якщо.місцезнаходження = Місцезнаходження {
      позиція_початку
    };
    вихід::вміст = гілка_якщо;
    вихід_позиції_кінця::вміст = п;
    вернути так;
    звільнити_і_вийти:
    звільнити_гілку(дані_гілки_якщо.умова);
    звільнити_тіло(дані_гілки_якщо.тіло);
    звільнити_тіло(дані_гілки_якщо.тіло_інакше);
    вернути ні;
  }

  дія спробувати_розібрати_поки(слова: Накопичувач<Слово>, позиція_початку: позитивне, вихід: адреса<адреса<Гілка>>, вихід_позиції_кінця: адреса<позитивне>): логічне {
    ціль дані_гілки_поки = ДаніГілкиПоки {
      умова = пусто,
      тіло = СписокГілок { 0, пусто }
    };
    змінна ціль п: позитивне = позиція_початку;
    // поки?
    якщо слова.дані[п].вид != ВидСловаПоки {
      стрибнути звільнити_і_вийти;
    }
    п += 1;
    // умова поки
    якщо спробувати_розібрати_молекулу(слова, п, дані_гілки_поки.умова::адреса, п::адреса) {
      п += 1;
    } інакше {
      стрибнути звільнити_і_вийти;
    }
    якщо слова.дані[п].вид != ВидСловаСимволМіжряд {
      стрибнути звільнити_і_вийти;
    }
    п += 1;
    // тіло поки
    якщо спробувати_розібрати_тіло(слова, п, дані_гілки_поки.тіло::адреса, п::адреса, ВидСловаКінець) == ні {
      стрибнути звільнити_і_вийти;
    }
    ціль гілка_поки = виділити<Гілка>();
    гілка_поки.вид = ВидГілкиПоки;
    гілка_поки.дані = дані_гілки_поки;
    гілка_поки.місцезнаходження = Місцезнаходження {
      позиція_початку
    };
    вихід::вміст = гілка_поки;
    вихід_позиції_кінця::вміст = п;
    вернути так;
    звільнити_і_вийти:
    звільнити_гілку(дані_гілки_поки.умова);
    звільнити_тіло(дані_гілки_поки.тіло);
    вернути ні;
  }

  дія спробувати_розібрати_цикл(слова: Накопичувач<Слово>, позиція_початку: позитивне, вихід: адреса<адреса<Гілка>>, вихід_позиції_кінця: адреса<позитивне>): логічне {
    вернути ні;
  }

  дія спробувати_розібрати_перебрати(слова: Накопичувач<Слово>, позиція_початку: позитивне, вихід: адреса<адреса<Гілка>>, вихід_позиції_кінця: адреса<позитивне>): логічне {
    ціль дані_гілки_перебрати = ДаніГілкиПеребрати {
      предмет = пусто,
      ідентифікатор = можливо<Ідентифікатор> { позитивне(ні), ... },
      тіло = СписокГілок { 0, пусто }
    };
    змінна ціль п: позитивне = позиція_початку;
    // перебрати?
    якщо слова.дані[п].вид != ВидСловаПеребрати {
      стрибнути звільнити_і_вийти;
    }
    п += 1;
    // значення перебрати
    якщо спробувати_розібрати_молекулу(слова, п, дані_гілки_перебрати.предмет::адреса, п::адреса) {
      п += 1;
    } інакше {
      стрибнути звільнити_і_вийти;
    }
    якщо слова.дані[п].вид == ВидСловаЯк {
      п += 1;
      якщо слова.дані[п].вид != ВидСловаІдентифікатор {
        стрибнути звільнити_і_вийти;
      }
      дані_гілки_перебрати.ідентифікатор = можливо<Ідентифікатор> {
        позитивне(так),
        Ідентифікатор { п }
      };
      п += 1;
    }
    якщо слова.дані[п].вид != ВидСловаСимволМіжряд {
      стрибнути звільнити_і_вийти;
    }
    п += 1;
    // тіло перебрати
    якщо спробувати_розібрати_тіло(слова, п, дані_гілки_перебрати.тіло::адреса, п::адреса, ВидСловаКінець) == ні {
      стрибнути звільнити_і_вийти;
    }
    ціль гілка_перебрати = виділити<Гілка>();
    гілка_перебрати.вид = ВидГілкиПеребрати;
    гілка_перебрати.дані = дані_гілки_перебрати;
    гілка_перебрати.місцезнаходження = Місцезнаходження {
      позиція_початку
    };
    вихід::вміст = гілка_перебрати;
    вихід_позиції_кінця::вміст = п;
    вернути так;
    звільнити_і_вийти:
    звільнити_гілку(дані_гілки_перебрати.предмет);
    звільнити_тіло(дані_гілки_перебрати.тіло);
    вернути ні;
  }

  дія спробувати_розібрати_спробувати(слова: Накопичувач<Слово>, позиція_початку: позитивне, вихід: адреса<адреса<Гілка>>, вихід_позиції_кінця: адреса<позитивне>): логічне {
    ціль дані_гілки_спробувати = ДаніГілкиСпробувати {
      тіло = СписокГілок { 0, пусто },
      ідентифікатор_зловити = можливо<Ідентифікатор> { позитивне(ні), ... },
      тіло_зловити = СписокГілок { 0, пусто }
    };
    змінна ціль п: позитивне = позиція_початку;
    // спробувати?
    якщо слова.дані[п].вид != ВидСловаСпробувати {
      стрибнути звільнити_і_вийти;
    }
    п += 1;
    якщо слова.дані[п].вид != ВидСловаСимволМіжряд {
      стрибнути звільнити_і_вийти;
    }
    п += 1;
    // тіло спробувати
    якщо спробувати_розібрати_тіло(слова, п, дані_гілки_спробувати.тіло::адреса, п::адреса, ВидСловаЗловити) == ні {
      стрибнути звільнити_і_вийти;
    }
    п += 1;
    якщо слова.дані[п].вид == ВидСловаІдентифікатор {
      дані_гілки_спробувати.ідентифікатор_зловити = можливо<Ідентифікатор> {
        позитивне(так),
        Ідентифікатор { п }
      };
      п += 1;
    }
    якщо слова.дані[п].вид != ВидСловаСимволМіжряд {
      стрибнути звільнити_і_вийти;
    }
    п += 1;
    // тіло зловити
    якщо спробувати_розібрати_тіло(слова, п, дані_гілки_спробувати.тіло_зловити::адреса, п::адреса, ВидСловаКінець) == ні {
      стрибнути звільнити_і_вийти;
    }
    ціль гілка_спробувати = виділити<Гілка>();
    гілка_спробувати.вид = ВидГілкиСпробувати;
    гілка_спробувати.дані = дані_гілки_спробувати;
    гілка_спробувати.місцезнаходження = Місцезнаходження {
      позиція_початку
    };
    вихід::вміст = гілка_спробувати;
    вихід_позиції_кінця::вміст = п;
    вернути так;
    звільнити_і_вийти:
    звільнити_тіло(дані_гілки_спробувати.тіло);
    звільнити_тіло(дані_гілки_спробувати.тіло_зловити);
    вернути ні;
  }
}

зовнішня дія розібрати_мавку(текст_коду: адреса<мавка::ТекстКоду>): адреса<мавка::РезультатРозборуМавки> {
  вернути пусто;
}

// потім: виправити розбір на слова чисел (0д, 0ш і тд)
// потім: виправити розбір на слова тексту (екранізація)
// потім: виправити розбір на слова а[0] (проблема в числах)

дія старт(кількість_аргументів: ц32, аргументи: памʼять<памʼять<п8>>): ц32 {
  ціль код_ю8 = ю8 { пусто, 0 };
  код_ю8.розмір = позитивне(read_file(аргументи[1] як памʼять<char>, size_t(порахувати_розмір_ю8сі(аргументи[1])), код_ю8.дані::адреса як адреса<памʼять<char>>));
  змінна ціль текст_коду = виділити<мавка::ТекстКоду>();
  текст_коду.шлях = ю8 { аргументи[1], порахувати_розмір_ю8сі(аргументи[1]) };
  текст_коду.значення = код_ю8;
  змінна ціль слова: Накопичувач<мавка::Слово>;
  якщо мавка::розібрати_на_слова(текст_коду, слова::адреса) == ні {
    надрукувати_ю8(ю8"не вдалось розібрати на слова");
    вернути 1;
  }
  мавка::надрукувати_слова(слова);
  змінна ціль тіло = мавка::СписокГілок { 0, пусто };
  змінна ціль позиція_кінця_тіла: позитивне = 0;
  надрукувати_ю8(ю8"---");
  якщо мавка::спробувати_розібрати_тіло(слова, 0, тіло::адреса, позиція_кінця_тіла::адреса, мавка::ВидСловаКІНЕЦЬСЛІВ) {
    надрукувати_ю8(ю8"Тіло успішно розібрано");
    надрукувати_ю8(ю8"---");
    змінна ціль п: позитивне = 0;
    поки п < тіло.довжина {
      мавка::вивести_гілку(тіло.елементи[п]);
      вивести_ю8(ю8"\n");
      п += 1;
    }
  } інакше {
    надрукувати_ю8(ю8"Тіло не розібрано");
  }
  вернути 0;
}